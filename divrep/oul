#!/opt/maths/bin/perl -w
use strict;
use feature 'current_sub';  # support __SUB__
use Math::GMP;
use Math::Prime::Util qw{
    is_prime divisors factor_exp prime_iterator chinese
};
use Algorithm::Loops qw{ NextPermuteNum NestedLoops };
use Syntax::Keyword::Dynamically;
use POSIX qw{ :sys_wait_h };
use Memoize;
use List::Util qw{ first sum0 };
use DDP;    # exports p, np
use lib 'lib';
use Type;
use Seq::Db;

=head1 oul - constrain upper limit of oneseq(n, k)

Try to find the parameters most likely to get a hit.

=cut

use lib './lib';
use ModFunc qw/ mod_combine quadvec gcd /;

sub MBI { return Math::GMP->new(@_) }
my $zero = MBI(0);
my $zone = MBI(1);

my($max, $start, $inject, $verify, $debug) = (0) x 5;
my $typename = 'o';
my $maxproc = 6;

while (@ARGV && $ARGV[0] =~ /^-/) {
    my $arg = shift @ARGV;
    last if $arg eq '--';
    ($max = $arg || shift(@ARGV)), next if $arg =~ s{^-x}{};
    ($start = $arg || shift(@ARGV)), next if $arg =~ s{^-s}{};
    $inject = 1, next if $arg eq '-i';
    $verify = 1, next if $arg eq '-v';
    ++$debug, next if $arg eq '-d';
    die "Unknown option '$arg'\n";
}

$| = 1;
my($n, $k) = map MBI($_), @ARGV;
$0 = "oul($n $k)";
my $type = Type->new($typename);
$type->bind($n);
$type->bind_owner('upperlim');
my $db = Seq::Db->new($type, 0);

my @nf = factor_exp($n);
my $tn = tau($n, \@nf);
my $t0 = scalar times();

my $min = g()->checked;
$max = ston($max) if $max;
$debug && warn "min=$min, max=$max\n";

if ($k == 1) {
    find_one($n, \@nf);
} else {
    find_any($n, \@nf);
}
exit 0;

{
    my $s; BEGIN { $s = '' }
    sub diag {
        print "\x08 \x08" x length($s);
        ($s) = @_;
        print $s;
    }
}

#
# Find the least element a_i of A025487 that has tau(a_i) = n: generate
# each of the ways to split n into factors, and construct a corresponding
# element of a_i that generates the required tau() that way.
#
sub find_one {
    my($n, $nf) = @_;
    my($r, $fh) = prep_run($n, 1, 1);

    my $best;
    my @p = nprimes(sum0 map $_->[1], @$nf);
    my $fit = factor_iterator($n, $nf);
    while (my $fact = $fit->()) {
        my $prod = $zone;
        for (0 .. $#$fact) {
            $prod *= $p[$_] ** ($fact->[$_] - 1);
        }
        printf $fh <<OUT, $prod, times() - $t0;
202 Candidate %s (%.2fs)
OUT
        $best = $prod if !defined($best) || $best > $prod;
    }
    finish_run($r, $fh, $best);
    return;
}

sub find_any {
    my($n, $nf) = @_;
    my($r, $fh) = prep_run($n, $k, 1);
    my $fa = dual_factorizations($n, $nf);
    my $best;

    my $cand = sub {
        my($new) = @_;
        return unless $new;
        printf $fh <<OUT, $new, times() - $t0;
202 Candidate %s (%.2fs)
OUT
        $best = $new unless $best && $best < $new;
        return;
    };
    # product of primes allocated so far, that should be avoided
    my $used = $zone;
    #
    # elements v[0..k-1] represent the composition of the value d+i that
    # we're trying to build up. Each element is a hashref of:
    #   f => the factorization we're using from $fa
    #   p[] => primes we've allocated to the factors
    #   q => total value attributed
    #   t => tau() not yet accounted for (ie n / tau(q))
    #
    my @v;
    my $recurse = sub {
        my $i = best_v(\@v) // goto final;
        my $v = $v[$i];
        my $pi = @{ $v->{p} } + 1;
        my $f = $v->{f};
        my $x = $f->[$pi];

        # try to add another factor to this $v: check all primes if different,
        # or only greater primes if the same power as previous power.
        my $p = ($pi && $f->[$pi - 1] == $x) ? $v->{p}[-1] : $zone;
        my $tnext = $v->{t} / $x;
        if ($best) {
            my $targ = $best / $v->{q} / mintau($tnext, $used);
            my $lim = $targ->broot($x);
            return if $lim < $p + 1;
            my $aq = $zone;
            $aq *= $_->{q} for @v;
            my $walk = $best / $aq;
            goto final if $walk < $lim;
        }
        push @{ $v->{p} }, undef;
        local $v->{t} = $tnext;

        while (1) {
            $p = next_zprime($p);
            next if $used % $p == 0;
            dynamically $used = $used * $p;
            my $px = $p ** ($x - 1);
            $v->{p}[-1] = $p;
            local $v->{q} = $v->{q} * $px;
            if ($best) {
                my $min = mintau($v->{t}, $used);
                if ($v->{q} * $min > $best) {
                    $debug && warn "for $i last at [@{ $v->{p} }] ($v->{q} * $min > $best)\n";
                    last;
                }
            }
            __SUB__->();    # recurse
        }
        pop @{ $v->{p} };
        return;

      final:
        # nothing more to allocate, or worth allocating
        my $result = walk_v(\@v, $best);
        return $cand->($result);
    };

    # Iterate over each possible assignment of $k factorizations
    my $fa_iter = order_iter($k, scalar @$fa);
    while (my $fo = $fa_iter->()) {
        @v = map +{
            f => $fa->[$_],
            p => [],
            q => $zone,
            t => $n,
        }, @$fo;
        $recurse->();
    }

    finish_run($r, $fh, $best);
    return;
}

# FIXME: gcd(p, k) would be faster than gcd(p^x, k); any(k==0 (mod p_i))
# might be faster still
sub walk_v {
    my($v, $best) = @_;
    my @q = map $_->{q}, @$v;
    my @t = map $_->{t}, @$v;
    my @qq = do {
        my $qq = $zone;
        $qq *= $_ for @q;
        map $qq / $_, @q;
    };

    # find m: 2^x | m (mod (2p)^x), 3^x | m+diff (mod (2p)^x)
    my $m = find_common_mod(\@q);
    return if $best && $m > $best;

    my @o = map +($m + $_) / $q[$_], 0 .. $#q;
    # special case any t[i] == 1
    for my $i (0 .. $#t) {
        next unless $t[$i] == 1;
        return unless $o[$i] == 1;
        for my $j (0 .. $#t) {
            next if $i == $j;
            return unless tau($o[$j]) == $t[$j];
            return unless gcd($o[$j], $q[$j]) == 1;
        }
        return $m;
    }

    my $end = $best ? $best / $q[0] : 0;
    while (!$end || $o[0] <= $end) {
        $debug > 1 && warn "walk_v: test [@o]\n";
        my $result = 1;
        for my $i (0 .. $#o) {
            $result = 0, last unless (
                tau($o[$i]) == $t[$i]
                && gcd($o[$i], $q[$i]) == 1
            );
        }
        return $o[0] * $q[0] if $result;
        # step the candidates by prod q_i
        $o[$_] += $qq[$_] for 0 .. $#o;
    }
    return;
}


# find the best entry to progress: the one with the highest tau()
# still to fulfil, or (on equality) with the highest q, but having
# at least one factor to allocate.
sub best_v {
    my($v) = @_;
    my($i, $vi);
    for my $j (0 .. $#$v) {
        my $vj = $v->[$j];
        my $next_factor = $vj->{f}[@{ $vj->{p} } + 1];
        # skip if no factor
        next unless $next_factor;

        if ($vi) {
            # doesn't have higher tau
            next if $vj->{t} < $vi->{t};
            # doesn't have higher q
            next if $vj->{t} == $vi->{t} && $vj->{q} <= $vi->{q};
        }
        ($i, $vi) = ($j, $vj);
    }
    return $i // undef;
}

sub mintau {
    my($tau, $avoid) = @_;
    my $fa = factorizations($tau);
    my %avoid = map +($_->[0] => 1), factor_exp($avoid);
    my @p = grep !$avoid{$_}, nprimes(@{ $fa->[-1] } + keys %avoid);

    my $best;
    for my $f (@$fa) {
        my $b = $zone;
        for (my $i = 0; $i < @$f; ++$i) {
            $b *= $p[$i] ** ($f->[$i] - 1);
        }
        $best = $b unless $best && $best < $b;
    }
    return $best;
}

sub find_common_mod {
    my($q) = @_;
    my $result = chinese(map [ -$_, $q->[$_] ], 0 .. $#$q);
    if (!defined $result) {
        use Carp; confess("[@$q]");
    }
    return $result;
}

sub prep_run {
    my($n, $k, $complete) = @_;
    return (undef, *STDOUT) unless $inject;
    my $g = g();
    my $f = Seq::TauF->forceFor($g, $db, $k);
    my $r = Seq::Run->gen($f, $db, {
        optn => $zero,
        optx => $zero,
        optc => 0,
        priority => 0,
        partial => !$complete,
    });
    $r->running(1);
    $r->update;
    my $path = $r->logpath($type);
    open(my $fh, '>', $path) or die "$path: $!";
    print $fh "001 $0\n";
    return ($r, $fh);
}

sub finish_run {
    my($r, $fh, $best) = @_;
    my $checked = report_seq($fh, $n, $k, $best);
    if ($checked) {
        printf <<OUT, $n, $k, $best;
265 check ok f(%s, %s) = %s
OUT
    } else {
        printf <<OUT, $n, $k, $best;
565 check not ok f(%s, %s) != %s
OUT
    }
    if ($verify) {
        my $g = g();
        my $f = Seq::TauF->forceFor($g, $db, $k);
        if ($f->complete) {
            if ($f->f == $best) {
                printf <<OUT, $n, $k, $best;
266 db ok f(%s,%s) = %s
OUT
            } else {
                printf <<OUT, $n, $k, $f->f, $best;
566 db not ok f(%s,%s) = %s, not %s
OUT
                goto finish_fail;
            }
        } else {
            if ($g->checked < $best) {
                printf <<OUT, $n, $k, $g->checked, $best;
366 db maybe ok f(%s,%s) ?= %s < %s
OUT
            } else {
                printf <<OUT, $n, $k. $best;
566 db not ok f(%s,%s) > %s, not %s
OUT
                goto finish_fail;
            }
        }
    }
    if ($checked) {
        printf $fh <<OUT, $n, $k, $best, times() - $t0;
200 f(%s, %s) = %s (%.2fs)
OUT
    }
    if ($inject) {
        close $fh;
        $r->finalize($db);
    }
    return;
  finish_fail:
    if ($inject) {
        close $fh;
        $r->delete;
    }
    exit 1;
}

sub report_seq {
    my($fh, $n, $k, $f) = @_;
    my($still_good, $all_good) = (1, 1);
    my @result;
    for (my $i = 0; ($i <= $k) || $still_good; ++$i) {
        my $v = $type->func_value($n, $i, $f);
        my $result = [ $i, $type->func($v), $v, pf($v) ];
        my $is_good = $type->func_matches($i, $result->[1]);
        $still_good = 0 unless $is_good;
        $all_good = 0 if $i < $k && !$is_good;
        push @result, $result;
    }
    my $flen = length($#result);
    my $vlen = length($result[-1][2]);
    my $name = $type->func_name;
    for (0 .. $#result) {
        my $r = $result[$_];
        printf $fh <<OUT, $flen, @$r[0, 1], $name, $vlen, @$r[2, 3];
211 Sequence % *s: % 2s = %s(% *s = %s)
OUT
    }
    return $all_good;
}

{
    my $g;
    sub g {
        return $g //= do {
            Seq::TauG->genTo($db, $n);
            $db->resultset('TauG')->find({ n => $n })
                    // die "cannot find TauG entry for n=$n";
        };
    }
}

#
# Return an ordering of the n-tuples of integers 0 .. size-1, such
# that sum is minimized, then lexicographically. Eg for n=2, size=3:
# (0,0); (0,1); (1,0); (0,2); (1,1); (2,0); (2,1); (1,2); (2,2).
# In legends below we have 'm' for max, "'" for successor, 0 <= a,b < m.
#
# CHECKME: do we also want to minimize max element, so that (0,1,1) comes
# before (0,0,2)?
#
sub order_iter {
    my($n, $size) = @_;
    my $max = $size - 1;
    my @t = (0) x $n;
    my $done = 0;
    return sub {
        return undef if $done;
        my @u = reverse @t;
        while (1) {
            # 00* -> 10*
            my $set = (first { $t[$_] } 0 .. $#t)
                    // (++$t[0], last);
            my $spare = (first { $t[$_] < $max } $set + 1 .. $#t) // do {
                # 0*am* -> m*a'0*
                (++$t[$set], @t = reverse @t), last if $t[$set] < $max;
                # 0*0m* -> m*10*
                (++$t[$set - 1], @t = reverse @t), last if $set;
                # m* -> done
                $done = 1, last;
            };
            # 0*a'm*b.* -> m*a0*b'.*
            --$t[$set];
            ++$t[$spare];
            @t[0 .. $spare - 1] = reverse @t[0 .. $spare - 1] if $spare > 1;
            last;
        }
        return \@u;
    };
}

sub _sortdual {
    (@$a == 1 && @$b == 1) ? 0
    : (($a->[1] // 0) <=> ($b->[1] // 0)) || do {
        local $a = [ @$a[1 .. $#$a] ];
        local $b = [ @$b[1 .. $#$b] ];
        _sortdual();
    };
}

#
# Return an arrayref of factorizations of $n, in the same form as given
# by factorizations(), except that all factors that are powers of 2 are
# collected and given as a single initial factor. Results are returned
# in _ascending_ order of the remaining factors.
# Thus dual_factorizations(12) would return [ [4, 3], [2, 6], [1, 12] ].
#
sub dual_factorizations {
    return [ sort _sortdual map {
        my @f = @$_;
        my $bad = 0;    # skip any factorization with more than two 2^x entries
        my $pow2;
        for my $i (reverse 0 .. $#f) {
            my $v = $f[$i];
            my $ispow = ($v & ($v - 1)) ? 0 : 1;
            if (($v & ($v - 1)) == 0) {
                $bad = 1, last if $pow2;
                $pow2 = $v;
                splice @f, $i, 1;
            }
        }
        $bad ? () : [ $pow2 // $zone, @f ];
    } @{ factorizations(@_) } ];
}

#
# Return an arrayref of all the ways to factorize $n (with its factor_exp
# optionally provided as $nf) in reverse lexicographic order, each
# factorization represented as an arrayref of descending factors.
# Thus factorizations(12) would return [ [12], [6,2], [4,3], [3,2,2] ].
#
sub factorizations {
    my($n, $nf) = @_;
    my @f;
    my $fi = factor_iterator($n, $nf);
    while (my $f = $fi->()) {
        push @f, [ @$f ];
    }
    return \@f;
}

#
# Return an iterator that returns factorizations one at a time in the
# same order and in the same form as the contents of the arrayref
# returned by factorizations(). Returns undef to signal the end of
# the list.
#
sub factor_iterator {
    my($n, $nf) = @_;
    if ($n == 1) {
        my $done = 0;
        return sub {
            return $done++ ? undef : [];
        };
    }
    $nf //= [ factor_exp($n) ];
    my @f;
    my %p = map +($_->[0] => 1), @$nf;
    return sub {
        unless (@f) {
            @f = ($n);
            return \@f;
        }
        my $prod = $zone;
        $prod *= pop(@f) while @f && $p{$f[-1]};
        return undef unless @f;
        my $prev = pop @f;
        $prod *= $prev;
        1 while $prod % --$prev;
        push @f, $prev;
        $prod /= $prev;
        while (1) {
            if ($prod <= $prev) {
                push @f, $prod;
                last;
            }
            --$prev while $prod % $prev;
            push @f, $prev;
            $prod /= $prev;
        }
        return \@f;
    };
}

sub next_zprime {
    my($p) = @_;
    my $q = Math::Prime::Util::next_prime($p);
    return MBI($q);
}

sub nprimes {
    my($count) = @_;
    my $it = prime_iterator;
    return map MBI($it->()), 1 .. $count;
}

sub modinv {
    my($n, $m) = @_;
    return MBI($n)->bmodinv($m);
}

sub tau {
    my($n, $fact) = @_;
    $fact //= [ factor_exp($n) ];
    my $k = 1;
    $k *= $_->[1] + 1 for @$fact;
    return $k;
}

sub pf {
    my $n = shift;
    return join '.', map {
        $_->[1] == 1 ? $_->[0] : "$_->[0]^$_->[1]"
    } factor_exp($n);
}

sub ston {
    my($s) = @_;
    $s =~ s/,//g;
    $s =~ s{e(\d+)}{"0" x $1}ie;
    return MBI($s);
}

sub ntos {
    my($n) = @_;
    $n =~ s{(0+)$}{"e" . length($1)}e;
    return $n;
}

sub _group {
    my($array) = @_;
    my %result;
    ++$result{$_} for @$array;
    return \%result;
}

BEGIN {
    memoize('comb');
    sub comb {
        my($n, $k) = @_;
        return ($k == 0) ? 1
                : ($k < 0 || $k > $n) ? 0
                : ($k == 1) ? $n
                : ($k + $k > $n) ? comb($n, $n - $k)
                : comb($n - 1, $k - 1) + comb($n - 1, $k);
    }
}

