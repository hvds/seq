#!/opt/maths/bin/perl
use strict;
use warnings;
use Math::Prime::Util qw{ factor_exp is_prime divisors };

=head1 totient

Exploratory code to develop an algorithm that finds x: phi(x) = n.

Assume small integers for now.

=cut

our $DEBUG = 0;
my($n) = @ARGV;
my @t = totient($n, {});
print @t ? "@t\n" : "none\n";
exit 0;

my @fermat; BEGIN { @fermat = (
    [ 1, 3 ], [ 2, 5 ], [ 4, 17 ], [ 8, 257 ], [ 16, 65537 ],
) }
sub totient {
    my($n, $used) = @_;
$DEBUG && warn "try $n [@{[ sort { $a <=> $b } keys %$used ]}]\n";
($DEBUG && warn("  n=1 => (1,2)\n")),
    return (1, 2) if $n == 1;
($DEBUG && warn("  n odd => ()\n")),
    return () if $n & 1;
($DEBUG && warn("  n=2 => @{[ $used->{3} ? (4) : (3, 4, 6) ]}\n")),
    return $used->{3} ? (4) : (3, 4, 6) if $n == 2;

    my $fn = [factor_exp($n)];
    my(%result, @used);
    # first try using any odd prime that divides n
    for my $i (reverse 1 .. $#$fn) {
        my($pi, $ei) = @{ $fn->[$i] };
        next if $used->{$pi};
$DEBUG && warn("  try power of factor $pi\n");
        push @used, $pi;
        next if $n % ($pi - 1);
        my $xu = $pi;
        my $nu = $n / ($pi - 1);
        local @$used{@used} = (1) x @used;
        for my $eu (0 .. $ei) {
$DEBUG && warn("  got power of factor $pi: $xu * $_\n");
            $result{$xu * $_} = 1 for totient($nu, $used);
            $xu *= $pi;
            $nu /= $pi;
        }
$DEBUG && warn("  end power of factor $pi\n");
    }
    # any remaining results must be squarefree other than powers of 2
    if (!$used->{$n + 1} && is_prime($n + 1)) {
$DEBUG && warn("  $n+1 is prime\n");
        $result{$n + 1} = 1;
        $result{($n + 1) * 2} = 1; # 2 is never "used"
    }

    # any remaining result is also composite
    # if n is 2 mod 4, no further solutions possible
    my $e2 = $fn->[0][1];
($DEBUG && warn("end 2 mod 4 giving [@{[ sort { $a <=> $b } keys %result ]}]\n")),
    return sort { $a <=> $b } keys %result if $e2 == 1;

    if (@$fn > 1) {
        my $base = 2 * $fn->[-1][0];
        my $rest = $n / $base;
$DEBUG && warn("  try top factor $base\n");
        for my $d (divisors($rest)) {
            last if $d == $rest;
            my $pi = $base * $d + 1;
            next if $used->{$pi} || !is_prime($pi);
            local $used->{$pi} = 1;
$DEBUG && warn("  got top factor $base -> $pi * $_\n");
            $result{$pi * $_} = 1 for totient($rest / $d, $used);
        }
$DEBUG && warn("end top factor giving [@{[ sort { $a <=> $b } keys %result ]}]\n");
        return sort { $a <=> $b } keys %result;
    }

    # what's left is 2^e2; assume only the 5 known fermat primes are relevant
    @used = ();
$DEBUG && warn("  try 2^$e2\n");
    for (@fermat) {
        my($pow, $prime) = @$_;
        last if $pow > $e2;
        next if $used->{$prime};
        push @used, $prime;
        local @$used{@used} = (1) x @used;
$DEBUG && warn("  with 2^$pow got $prime * $_\n");
        $result{$prime * $_} = 1 for totient($n / ($prime - 1), $used);
    }
$DEBUG && warn("  got 2^$e2 * 2\n");
    $result{$n * 2} = 1;
$DEBUG && warn("end 2^$e2 giving [@{[ sort { $a <=> $b } keys %result ]}]\n");
    return sort { $a <=> $b } keys %result;
}
