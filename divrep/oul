#!/opt/maths-GMP/bin/perl
use strict;
use warnings;
use Math::GMP;
use Math::Prime::Util qw{
    factor_exp prime_iterator divisors next_prime valuation prime_count
    is_prime is_semiprime is_power
};
use Math::Prime::Util::GMP qw{ chinese };
use List::Util qw{ first sum0 all min };
use Algorithm::Loops qw{ NestedLoops };

use lib 'lib';
use Type;
use Seq::Db;
use ModFunc qw{ gcd };
use RootMod qw{ allsqrtmod allrootmod };
use Math::Pell ();  # will fully qualify use

local $SIG{FPE} = sub { use Carp; confess("Division by zero") };

*is_tau = Math::Prime::Util::GMP->can('is_tau') // \&_is_tau;

=head1 oul - find min value of oneseq(n, k)

That is, find the least d such that tau(d + i) == n for all 0 <= i < k.

The core approach is to allocate in turn each small enough prime p
to fill a slot p^x in the value v_i = d + i, contributing a factor
x + 1 to tau(v_i). When enough slots are allocated, we then use the
Chinese remainder theorem to determine what d (mod a) must be, where
a is the product of all the allocated p^x, and test each value of d
until we find a solution or hit the limit (a previously found solution,
a user-specified maximum, or no limit).

=cut

sub MBI { return Math::GMP->new(@_) }
my $zero = MBI(0);
my $zone = MBI(1);

my($max, $inject, $debug, $nodb) = (0) x 4;
my($rrun, $cap, $gain, $start, $forcefull, $print, $forcep);
my $typename = 'o';
my $maxproc = 6;
my $seen_best = 0;

while (@ARGV && $ARGV[0] =~ /^-/) {
    my $arg = shift @ARGV;
    last if $arg eq '--';
    ($max = $arg || shift(@ARGV)), next if $arg =~ s{^-x}{};
    ($gain = $arg || shift(@ARGV)), next if $arg =~ s{^-g}{};
    ($rrun = $arg || shift(@ARGV)), next if $arg =~ s{^-r}{};
    ($cap = $arg || shift(@ARGV)), next if $arg =~ s{^-p}{};
    ($forcep = $arg || shift(@ARGV)), next if $arg =~ s{-fp}{};
    ($start = length($arg) ? $arg : shift @ARGV), next if $arg =~ s{^-s}{};
    $inject = 1, next if $arg eq '-i';
    $nodb = 1, next if $arg eq '-n';
    $print = 1, next if $arg eq '-o';
    $forcefull = 1, next if $arg eq '-f';
    ++$debug, next if $arg eq '-d';
    die "Unknown option '$arg'\n";
}

if ($nodb && ($rrun || $inject)) {
    die "Incompatible options: cannot recover or inject without database";
}

$| = 1;
my $type = Type->new($typename);
$type->bind_owner('upperlim');
my $db = $nodb ? undef : Seq::Db->new($type, 0);

my($n, $k, $r, $fh, $t0,  @rstack, $rwalk);
$max = ston($max) if $max;
if ($rrun) {
    ($r, $fh) = recover($rrun);
} else {
    ($n, $k) = @ARGV;
}
$gain //= 1;
$start //= 0;
$forcep //= $k;
$0 = "oul($n $k)";
$type->bind($n);

# When k >= p^2 + 1, it is possible to assign more than one power of p.
my $max_repeat = int(sqrt($k - 1));

my $nf = [ factor_exp($n) ];
my $tn = tau($n, $nf);
my(%fact, %fullfact, %nofact);
prep_fact($n);
prep_mintau();

my($diag_delay, $log_delay) = (1, 600);
$t0 = 0 unless $rrun;
my($diagt, $logt) = ($diag_delay, $log_delay);

$max ||= f()->f unless $nodb;       # set from db if not specified

my $best = $max || undef;
my $have_best = $best ? 1 : 0;
our $have_square = 0;

# Ensure the Run object is marked 'partial' if not a full run
my $complete = defined($cap) ? 0 : 1;

# Lookup of primes allocated so far, that should be avoided
my %used;

#
# Elements v[0..k-1] represent the composition of the value d+i that
# we're trying to build up. Each element is a hashref of:
#   p[] => primes we've allocated to the factors
#   x[] => the power we've raised those primes to
#   pu{} => lookup of p[] to x[]
#   q => total value attributed
#   t => tau() not yet accounted for (ie n / tau(q))
#   l => level: how many entries in p[] and x[] are valid
#   force{} => lookup { p => x } of forced minimal powers
#   forced => product of force{p}
#
my @v = map +{
    p => [], pu => {}, x => [], q => $zone, t => $n, l => 0,
    force => {}, forced => 1,
}, 0 .. $k - 1;

# Recursion level
my $level = 0;
# LCM of v[i]{q} per recursion level
my @aq = ($zone);
# powers of primes included in @aq
my %pp;

# Each element of %pforce is an arrayref of [ key, batch ]; the key
# is of the form "x:i1 i2 i3 ..." where x is the highest power of
# p, and i1, i2 ... are the indices at which we find that power.
my %pforce;
do {
    my $p = 2;
    while ($p <= $forcep) {
        prep_forcep($p);
        $p = next_prime($p);
    }
};

my($countr, $countw) = (0, 0);

my @injected = (0) x $k;
my @minp;
prep_minp();

($r, $fh) = prep_run($n, $k, $complete) if $inject && !$rrun;
report(sprintf "001 %s%s%s%s%s%s\n",
    ($rrun ? 'recover ' : ''),
    $0, ($cap ? " -p$cap" : ""), ($gain > 1 ? " -g$gain" : ""),
    ($start ? " -s$start" : ""), ($max ? " -x$max" : ""),
);

forcep(2, $rrun ? 1 : 0);
finish_run();
exit 0;

# For debugging or sharding: inject assignment of p^x into a_i.
sub inject {
    my($i, $p, $x) = @_;
    my $v = $v[$i];
    my $vlevel = $v->{l};
    my $px = MBI($p) ** $x;
    ++$x;
    my($ax, $apx) = new_power($p, $x, $px);

    # never localized
    $v->{p}[$vlevel] = $p;
    $v->{x}[$vlevel] = $x;

    # when recursing, these changes are localized
    $v->{l} = $v->{l} + 1;
    $pp{$p} = $ax;
    $aq[$level + 1] = $aq[$level] * $apx;
    $v->{pu}{$p} = $x;
    $v->{q} = $v->{q} * $px;
    $v->{t} = $v->{t} / $x;
    ++$have_square if ($v->{t} & 1) && !($x & 1);
    $used{$p} = $i;
    ++$level;
    ++$injected[$i];
    return;
}

{
    my $s; BEGIN { $s = '' }
    sub diag {
        print "\x08 \x08" x length($s);
        ($s) = @_;
        print $s;
        return;
    }
    sub keep_diag {
        if (length $s) {
            print "\n";
            $s = '';
        }
        return;
    }
}

sub report {
    my($msg) = @_;
    print $fh $msg if $fh;
    keep_diag();
    print $msg;
    return;
}

sub do_diag {
    my($msg) = @_;
    diag($msg);
    $diagt = times() + $diag_delay;
    if ($fh && times() >= $logt) {
        print $fh sprintf "305 %s (%.2fs)\n", $msg, times() - $t0;
        $logt = times() + $log_delay;
    }
    return;
}

sub candidate {
    my($new) = @_;
    return unless $new;
    report(sprintf <<OUT, $new, times() - $t0);
202 Candidate %s (%.2fs)
OUT
    unless ($have_best && $best < $new) {
        $best = $new;
        $have_best = 1;
        $seen_best = 1;
    }
    return;
}

sub desc {
    my($va) = @_;
    return join ' ', map {
        my($p, $x, $l) = @$_{qw{ p x l }};
        join('.', map {
            my($pi, $xi) = ($p->[$_], $x->[$_] - 1);
            ($xi == 1) ? $pi : "$pi^$xi"
        } 0 .. $l - 1) || '.';
    } @$va;
}

# Iterate through all possible settings for primes up to $forcep, then
# continue with recurse() to fill remaining slots.
sub forcep {
    my($p, $recover) = @_;
    return recurse($recover) if $forcep < $p;
    my $nextp = next_prime($p);
    my $pf = $pforce{$p};
    if ($recover) {
        # on recovery, we reduce @$pf to the list not yet tried
        (my($batch), $pf) = recover_forcep($p, $pf);
        batch_recurse($batch, 1, sub { forcep($nextp, @_) });
    }
    for my $force (@$pf) {
        my $batch = $force->[1];
        batch_recurse($batch, 0, sub { forcep($nextp, @_) });
    }
    return;
}

sub recurse {
    my($recover) = @_;
    my $i = best_v() // return candidate(walk_v());
    my $v = $v[$i];
    my $fa = $fact{$v->{t}} // die "No factor to work with for i=$i, t=$v->{t}";
    my $vlevel = $v->{l};
    my $prex = $vlevel ? $v->{x}[$vlevel - 1] : 0;
    my $p0;

    if ($v->{forced} > 1) {
        my $p = min keys %{ $v->{force} };
        my $xm = delete local $v->{force}{$p};
        my $forced = $v->{forced} / $xm;
        local $v->{forced} = $forced;
        my $pxm = $p ** ($xm - 1);
        my @known;
        for (my $j = $i % $pxm; $j < $k; $j += $pxm) {
            my $xk = $v[$j]{pu}{$p};
            push @known, defined($xk) ? $xk - $xm : undef;
        }
        my $im = int($i / $pxm);
        $fa = $fullfact{$v->{t}};
        if ($recover) {
            my $r = $rstack[$i][$vlevel];
            if (!$r) {
                $recover = 0;
            } else {
                my($rp, $rx) = @$r;
                ++$rx;
                if ($p != $rp) {
                    die "Forced $p is not recovering $rp ** $rx";
                }
                my $fai = first { $fa->[$_] == $rx } 0 .. $#$fa;
                die "power $rx does not exist in fullfact[$v->{t}]: [@$fa]"
                        unless defined $fai;
                $fa = [ @$fa[$fai .. $#$fa] ] if $fai;
            }
        }
        my $done = 1;
        for my $x (@$fa) {
            next if $x < $xm;
            next if $x * $forced > $v->{t};
            # If we're down to powers of 2, fall through to the main loop
            # unless we'd be forced to consume _all_ the powers of 2.
            $done = 0, last if (
                !$forcefull     # use -f to suppress the fallthrough
                && ($x & ($x - 1)) == 0
                && $x >= 2 * $xm
            );
            local $known[$im] = $x - $xm;
            next unless valid_set($p, \@known);
            my $batch = try_force($i, $p, $x);
            if ($batch) {
                batch_recurse($batch, $recover, \&recurse);
                $recover = 0;
                next;
            }
        }
        return if $done;
        # FIXME: when falling through here we'd like to mark somehow that
        # _at least_ ceil(log_2(xm)) powers of 2 will be consumed by some
        # p^{2^x-1} factor, restricting what factors are available for other
        # primes, but we can't simply modify v->{t} since that would cause
        # walk_*() to look for the wrong thing. Maybe we can find a way
        # to allocate p^x without walk_* rejecting candidates on the grounds
        # that v_i / q == 0 (mod p)
        $fa = $fact{$v->{t}} // return candidate(walk_v());
    }

    if ($recover) {
        my $r = $rstack[$i][$vlevel];
        if (!$r) {
            $recover = 0;
        } else {
            my($rp, $rx) = @$r;
            ++$rx;
            my $fai = first { $fa->[$_] == $rx } 0 .. $#$fa;
            die "power $rp^$rx does not exist at $i in fact[$v->{t}]: [@$fa]"
                    unless defined $fai;
            $fa = [ @$fa[$fai .. $#$fa] ] if $fai;
            $p0 = $rp;
        }
    } else {
        ++$countr;
    }

    my $this_recover;
  POWER:
    for my $x (@$fa) {
        $this_recover = 0;

        # CHECKME: for n=54, we should disallow eg x=9 when t=54, since we
        # will already have tried all x=3 and x=6 before that.
        next if $nofact{$x}{$prex} && $vlevel >= $injected[$i];

        # Try to add another factor to this $v. Check all primes if different,
        # or only greater primes if same power as previous power.
        my $p = ($prex == $x)
            ? $v->{p}[$vlevel - 1]
            : ($minp[$i][$x] //= 1);
        if ($recover) {
            $p = $p0 - 1;   # next_prime() will get us back to it
            $this_recover = 1;
            $recover = 0;
        }
        my $tnext = $v->{t} / $x;

        # We can get slightly better accuracy by recalculating this each
        # time in the loop below, at least for small $p, but the cost
        # outweighs the benefit.
        my $mint = mintau($tnext, $i);
        if ($have_best) {
            my $lim = $cap // (($best + $i) / $v->{q} / $mint)->broot($x - 1);
            next POWER if $lim < $p + 1;
            my $walk = ($best + $i) / $aq[$level];
            if ($have_square) {
                # If we fix a square, expect to actually walk sqrt($walk)
                # times number of roots mod $aq, typically 2**k if there
                # are k primes dividing $aq.
                my $lim2 = $lim * $lim >> scalar keys %used;
                $lim = $lim2 if $lim < $lim2;

                # If we fix multiple squares force the walk immediately:
                # solving the Pell equation won't be beaten by further recurse.
                $walk = 0 if $have_square > 1;
            }
            candidate(walk_v()), last POWER if $walk * $gain < $lim;
        }

        local $have_square = $have_square + 1 if ($tnext & 1) && !($x & 1);
        $v->{x}[$vlevel] = $x;
        local $v->{l} = $vlevel + 1;

        if ($tnext == 1) {
            my $q = $v->{q};
            while (1) {
                $p = next_prime($p);
                next POWER if defined($cap) && $p > $cap;
                next if defined $used{$p};
                my $qx = $q * MBI($p) ** ($x - 1);
                next POWER if $have_best && $qx > $best;
                my $result = walk_1($i, $qx - $i);
                candidate($result), next POWER if $result;
                if (times() >= $diagt) {
                    local $v->{p}[$vlevel] = $p;
                    do_diag(desc(\@v) . ": t=1");
                }
            }
        }

        my($have_pb, $pb) = ($have_best, $best);
        while (1) {
            $p = next_prime($p);
            last if defined($cap) && $p > $cap;
            next if defined $used{$p};
            # FIXME: make this a single ($p <= $max_force[$i]) check
            if ($p < $k && !($i - $p < 0 && $i + $p >= $k)) {
                my $batch = try_force($i, $p, $x) // next;
                local $v->{l} = $vlevel;
                batch_recurse($batch, $this_recover, \&recurse);
                $this_recover = 0;
                next;
            }

            local $used{$p} = $i;
            local $v->{pu}{$p} = $x;
            my $px = MBI($p) ** ($x - 1);
            $v->{p}[$vlevel] = $p;
            my $q = $v->{q} * $px;
            if ($have_best) {
                if ($q * $mint > $best + $i) {
                    $debug && warn "for $i last at [@{ $v->{p} }] ($q * $mint > $best)\n";
                    last;
                }
                if (!$have_pb || $best < $pb) {
                    ($have_pb, $pb) = ($have_best, $best);
                    my $lim = $cap // (($best + $i) / $v->{q} / $mint)->broot($x - 1);
                    next POWER if $lim < $p;
                    my $walk = ($best + $i) / $aq[$level];
                    candidate(walk_v()), last POWER if $walk * $gain < $lim;
                }
            }

            local $v->{t} = $tnext;
            local $v->{q} = $q;
            my($ax, $apx) = new_power($p, $x, $px);
            local $pp{$p} = $ax;
            local $aq[$level + 1] = $aq[$level] * $apx;
            ++$level;
            do_diag(desc(\@v)) if times() >= $diagt;
            recurse($this_recover);
            $this_recover = 0;
            --$level;
        }
    }
    $#{ $v->{p} } = $vlevel - 1;
    return;
}

sub batch_recurse {
    my($batch, $recover, $continue) = @_;
    if ($batch->{iforce} < @{ $batch->{force} }) {
        my($i, $p, $x) = @{ $batch->{force}[$batch->{iforce}] };
        local $batch->{iforce} = $batch->{iforce} + 1;
        # apply p^x at v_i
        my $v = $v[$i];
        my $vlevel = $v->{l};
        if ($recover) {
            my $r = $rstack[$i][$vlevel];
            if (!$r) {
                $recover = 0;
            } else {
                my($rp, $rx) = @$r;
                ++$rx;
                if ($rp != $p || $rx != $x) {
                    die "forcing $p ** $x but recovery wants $rp ** $rx";
                }
            }
        }
        return if $v->{t} % $x;

        my $px = MBI($p) ** ($x - 1);
        my($ax, $apx) = new_power($p, $x, $px);

        # not localized
        $v->{p}[$vlevel] = $p;
        $v->{x}[$vlevel] = $x;

        local $v->{l} = $v->{l} + 1;
        local $pp{$p} = $ax;
        local $aq[$level + 1] = $aq[$level] * $apx;
        local $v->{pu}{$p} = $x;
        local $v->{q} = $v->{q} * $px;
        local $v->{t} = $v->{t} / $x;
        local $have_square = $have_square + 1 if ($v->{t} & 1) && !($x & 1);
        local $used{$p} = $i;

        return if $v->{forced} > $v->{t};
        ++$level;
        if ($v->{t} == 1) {
            candidate(walk_1($i, $v->{q} - $i));
        } else {
            batch_recurse($batch, $recover, $continue);
        }
        --$level;
    } elsif ($batch->{imin} < @{ $batch->{min} }) {
        # FIXME: if there's at most one option < $v->{t} available, we
        # should walk_1() the $v->{t} option then set the remaining one.
        my($i, $p, $x) = @{ $batch->{min}[$batch->{imin}] };
        local $batch->{imin} = $batch->{imin} + 1;
        my $v = $v[$i];
        my $forced = $v->{forced};
        if ($v->{force}{$p}) {
            my $ox = $v->{force}{$p};
            $forced /= $ox;
            $x = $ox if $x < $ox;
        }
        local $v->{forced} = $forced * $x;
        return if $v->{forced} > $v->{t};
        local $v->{force}{$p} = $x;
        batch_recurse($batch, $recover, $continue);
    } else {
        return $continue->($recover);
    }
    return;
}

sub valid_set {
    my($p, $known) = @_;
    my(%seenzero, %seenmore);
    for (grep defined($known->[$_]), 0 .. $#$known) {
        my $got = $known->[$_];
        if ($got) {
            ++$seenmore{$_ % $p};
        } else {
            ++$seenzero{$_ % $p};
        }
    }
    return 0 if keys(%seenzero) >= $p;
    return 0 if keys(%seenmore) > 1;
    my($mod, $seen) = each %seenmore;
    return 1 if ($seen // 0) <= 1;
    my @higher;
    for (my $i = $mod; $i < @$known; $i += $p) {
        push @higher, $known->[$i] - 1;
    }
    return valid_set($p, \@higher);
}

sub try_force {
    my($i, $p, $x) = @_;

    my(@force, @min);
    for my $j (0 .. $k - 1) {
        my $tj = ($i == $j) ? $x + 1 : valuation($j - $i, $p) + 1;
        next if $tj == 1;
        # if already set, it's set to a power we would have picked
        next if $v[$j]{pu}{$p};

        if ($tj < $x) {
            # v_j cannot be divisible by p^{tj-1}
            return undef if $v[$j]{t} % $tj;
            # o(v_i, p) = x => o(v_j, p) = y if o(j-i, p) = y and y < x
            push @force, [ $j, $p, $tj ];
        } elsif ($tj > $x) {
            # v_j cannot be divisible by p^{x-1}
            return undef if $v[$j]{t} % $x;
            # o(v_i, p) = x => o(v_j, p) = x if o(j-i, p) = y and y > x
            push @force, [ $j, $p, $x ];
        } else {
            # o(v_i, p) = x => o(v_j, p) >= x if o(j-i, p) = y and y = x
            push @min, [ $j, $p, $x ];
        }
    }
    return {
        force => \@force,
        min => \@min,
        iforce => 0,
        imin => 0,
    };
}

sub new_power {
    my($p, $x, $px) = @_;
    # assign the whole p^x if we haven't seen p before
    my $op = $pp{$p} || return +($x, $px);
    # assign nothing if we've seen a higher p^x before
    return +($op, 1) if $op >= $x;
    # else assign the difference
    return +($x, MBI($p) ** ($x - $op));
}

sub walk_1 {
    my($i, $val) = @_;
    my @vi;
    $rwalk = undef; # ignore rwalk recovery for walk_1
    for (0 .. $#v) {
        next if $_ == $i;
        my $v = $v[$_];
        my($vi, $mod) = ($val + $_)->bdiv($v->{q});
        return undef if $mod;
        return undef if gcd($vi, $v->{q}) != 1;
        $vi[$_] = $vi;
    }
    if ($print) {
        print STDERR $val, "\n";
        return;
    }
    return undef unless all {
        is_tau($vi[$_], $v[$_]{t})
    } grep $_ != $i, 0 .. $#v;
    return $val;
}

sub walk_v {
    my $start;
    if ($rwalk) {
        # recovery: first time only
        $start = $rwalk;
        $rwalk = undef;
    }

    # allocated values
    my @q = map $_->{q}, @v;

    # find m: 2^x | m (mod (2p)^x), 3^x | m+diff (mod (2p)^x)
    my $m = MBI(chinese(map [ -$_, $q[$_] ], 0 .. $#q));
    return if $have_best && $m > $best;

    # unallocated tau
    my @t = map $_->{t}, @v;

    # gcd(@q)
    my $aq = $aq[$level];

    # Given o_i + k . qq_i == m + i (mod aq), need tau(o_i) == t_i
    my @qq = map $aq / $_, @q;
    my @o = map +($m + $_) / $q[$_], 0 .. $#q;

    my @square;
    my @check = $print ? () : do {
        # Categorize by required tau()
        my(@prime, @semi, @other);
        for my $i (0 .. $#o) {
            my $t = $t[$i];
            if ($t == 2) {
                push @prime, $i;
            } elsif ($t == 4) {
                push @semi, $i;
            } elsif ($t & 1) {
                push @square, $i;
            } else {
                push @other, $i;
            }
        }

        # Sort each category by smallest first (hence largest divisor)
        @$_ = sort { $q[$b] <=> $q[$a] } @$_ for (
            \@prime, \@semi, \@square, \@other
        );

        # Create callbacks for each element, and order the categories
        # fastest first: squares, primes, semiprimes, others
        (map { my $i = $_; my $t = $t[$i]; sub {
            return is_tau($o[$i], $t);
        } } @square, @prime, @semi, @other);
    };

    if (@square) {
        my $sqi = $square[0];
        my($o, $q, $qq, $t) = ($o[$sqi], $q[$sqi], $qq[$sqi], $t[$sqi]);
        # remove the unneeded @check entry for this $i
        shift @check;

        if (@square > 1) {
            my $sqj = $square[1];
            my($oj, $qj, $qqj, $tj) = ($o[$sqj], $q[$sqj], $qq[$sqj], $t[$sqj]);
            shift @check;
            my $limit = $have_best ? ($best / $q)->bsqrt : undef;
            # q_i x^2 - q_j y^2 + (j - i) = 0
            my $pell = Math::Pell::with_limit(sub {
                Math::Pell::full($q, 0, -$qj, 0, 0, $sqj - $sqi);
            }, $limit);
            my $atip = 0;
            my $pc = 0;
            while (1) {
                my($x, $y) = $pell->();
                return unless defined $x;
                my $x2 = $x * $x;
                return if $have_best && $x2 * $q - $sqi > $best;
                ++$countw;
                ++$pc;
                do_diag(desc(\@v) . ": P$pc") if times() >= $diagt;
                next unless $x2 % $qq == $o;
                my $y2 = $y * $y;
                next unless $y2 % $qqj == $oj;
                next if gcd($x, $qq) != 1;
                next if gcd($y, $qqj) != 1;
                next unless sqtau($x) == $t;
                next unless sqtau($y) == $tj;
                my $ati = ($x2 - $o) / $qq;
                next unless $ati == ($y2 - $oj) / $qqj;
                $o[$_] += $qq[$_] * ($ati - $atip) for 0 .. $#o;
                $atip = $ati;
                if (all { gcd($o[$_], $q[$_]) == 1 } 0 .. $#o) {
                    if ($print) {
                        print STDERR $o[0] * $q[0], "\n";
                    } else {
                        return $o[0] * $q[0] if all { $_->() } @check;
                    }
                }
            }
        }

        my $x = gcd(map $_ - 1, divisors($t[$sqi]));

        # We need to find r: r^x = o_i + j . qq_i
        my @xmod = sort { $a <=> $b } allrootmod($o, $x, $qq);
        return unless @xmod;

        my($rcycle, $rindex) = (0, 0);
        my $atip = 0;
        if ($start) {
            $o[$_] += $qq[$_] * $start for 0 .. $#o;
            $atip = $start;
            $rcycle = $start / $qq;
            $start %= $qq;
            $rindex = (first { $xmod[$_] >= $start } 0 .. $#xmod)
                    // do { ++$rcycle; 0 };
        }
        # CHECKME: might we get r: r^x < o_i for initial values?
        my $endr = $have_best ? (($best + $sqi) / $q)->broot($x) : undef;
        my $endi = $have_best ? $best / $aq : 0;
        my $qqr = $rcycle * $qq;
        while (1) {
            my $r = $xmod[$rindex] + $qqr;
            last if defined($endr) && $r > $endr;
            ++$countw;
            next if gcd($r, $qq) != 1;
            my $rx = $r ** $x;
            if (times() >= $diagt) {
                my $ati = ($rx - $o) / $qq;
                do_diag(desc(\@v) . ": $ati / $endi");
            }
            next unless is_tau($rx, $t);
            my $ati = ($rx - $o) / $qq;
            $o[$_] += $qq[$_] * ($ati - $atip) for 0 .. $#o;
            $atip = $ati;
            if (all { gcd($o[$_], $q[$_]) == 1 } 0 .. $#o) {
                if ($print) {
                    print STDERR $o[0] * $q[0], "\n";
                } else {
                    return $o[0] * $q[0] if all { $_->() } @check;
                }
            }
        } continue {
            ++$rindex;
            $qqr += $qq, $rindex = 0 if $rindex >= @xmod;
        }
        return;
    }

    #
    # This is the core loop, for long runs we expect to spend the bulk
    # of our time here (probably in factorization for the tau() checks).
    #
    if ($start) {
        $o[$_] += $qq[$_] * $start for 0 .. $#o;
    }
    my $end = $have_best ? $best / $q[0] : undef;
    my $endi = $have_best ? $best / $aq : 0;
    while (!defined($end) || $o[0] <= $end) {
        ++$countw;
        if (times() >= $diagt) {
            my $ati = $o[0] / $qq[0];
            do_diag(desc(\@v) . ": $ati / $endi");
        }

        # Print a candidate or return a solution if we find one.
        #
        # FIXME: maintain $ati and prepare inverses for each assigned
        # prime so the gcd check becomes a simple integer mod check:
        #   all { $ati % $invp[$_] != $invmod[$_] } 0 .. $#o
        # I think we can safely rely on both $ati and assigned primes
        # not to exceed range of exact integer maths.

        if (all { gcd($o[$_], $q[$_]) == 1 } 0 .. $#o) {
            if ($print) {
                print STDERR $o[0] * $q[0], "\n";
            } else {
                return $o[0] * $q[0] if all { $_->() } @check;
            }
        }

        # step the candidates by prod q_i
        $o[$_] += $qq[$_] for 0 .. $#o;
    }
    return;
}

# find the best entry to progress: the one with the highest tau()
# still to fulfil, or (on equality) with the highest q, but having
# at least one factor to allocate.
sub best_v {
    my($i, $vi);
    return $start if $level == 0;
    for my $j (0 .. $#v) {
        my $vj = $v[$j];
        # skip if no odd prime factor
        next unless $fact{$vj->{t}};
        # skip prime powers when capped
        next if $cap && ($vj->{t} & 1) && is_prime($vj->{t});

        if ($vi) {
            # doesn't have higher tau
            next if $vj->{t} < $vi->{t};
            # doesn't have higher q
            next if $vj->{t} == $vi->{t} && $vj->{q} <= $vi->{q};
        }
        ($i, $vi) = ($j, $vj);
    }
    return $i // undef;
}

sub prep_forcep {
    my($p) = @_;
    my $fact = $fullfact{$n};
    my($x, $px) = (1, 1);
    ++$x, $px *= $p while $px * $p < $k;

    if ($p > $k) {
        warn "Solutions with no element divisible by $p will be skipped\n";
        $complete = 0;
    }

    my @batch;
    $pforce{$p} = \@batch;

    for my $i (0 .. $k - 1) {
        for my $fx (@$fact) {
            next if $fx < $x;
            next if $fx == $x && ($i >= $px || $i + $px < $k);
            my $batch = try_force($i, $p, $fx) or next;
            if (@{ $batch->{min} }) {
                use DDP; p { p => $p, x => $fx, i => $i, batch => $batch };
                die "invalid batch in prep_forcep";
            }
            push @batch, [ "$fx:$i", $batch ];
        }
    }

    return if $p == 2 || $x == 1 || $n % ($x - 1);
    my $px2 = $px * ($p - 1);
    for my $i (0 .. $px - 1) {
        next if $i + $px2 <= $k - 1;
        my $batch = try_force($i, $p, $x) or next;
        my @min = splice @{ $batch->{min} };
        next unless @min;
        my $is = join ' ', ($i, map $_->[0], @min);
        push @{ $batch->{force} }, @min;
        push @batch, [ "$x:$is", $batch ];
    }
    return;
}

# on recovery, find the batch associated with this forced prime
sub recover_forcep {
    my($p, $pf) = @_;
    my($bestx, @besti) = (0);
    for my $i (0 .. $k - 1) {
        my $r = $rstack[$i][ $v[$i]{l} ] // next;
        my($rp, $rx) = @$r;
        next unless $rp == $p;
        if ($rx >= $bestx) {
            @besti = () if $rx > $bestx;
            $bestx = $rx;
            push @besti, $i;
        }
    }
    die "no power of $p to recover from" unless $bestx;
    ++$bestx;
    my $match = join ':', $bestx, join ' ', @besti;
    my $which = first { $pf->[$_][0] eq $match } 0 .. $#$pf;
    die "no pforce match for '$match'" unless defined $which;
    my $batch = $pf->[$which][1];
    $pf = [ @$pf[ $which + 1 .. $#$pf ] ];
    return +($batch, $pf);
}

# Prepare an element of the @mint array below
sub fill_mintau {
    my($tau, $primes) = @_;
    my @p = map MBI($_), @$primes;
    my(@r, @v);
    return [ [ 0, $zone ] ] if $tau == 1;

    # Find all values over the given primes, and associated bit vectors
    for my $f (@{ factorizations($tau) }) {
        NestedLoops([
            [ 0 .. $#$primes ],
            map sub {
                [ $_[-1] + 1 .. $#$primes ]
            }, 1 .. $#$f
        ], { OnlyWhen => 0 }, sub {
            my $vec = 0;
            my $val = $zone;
            for my $i (0 .. $#_) {
                my $j = $_[$i];
                $vec |= 1 << $j;
                $val *= $p[$j] ** ($f->[$i] - 1);
            }
            push @v, [ $vec, $val ];
        });
    }
    @v = sort { $a->[1] <=> $b->[1] } @v;

    # Repeatedly take best value, then discard any worse values that
    # would use the same primes.
    while (@v) {
        my $v = shift @v;
        push @r, $v;
        my $vec = $v->[0];
        @v = grep +($_->[0] & $vec) != $vec, @v;
    }
    return \@r;
}

{
    # $mint[$t] is an arrayref of possible mintau() values for tau=$t.
    # Each entry is an arrayref [ok_vector, value]; this value should be
    # returned if the bit vector of used primes has no bits in common
    # with ok_vector.
    my @mint;

    my @p;
    my %smallp;
    sub prep_mintau {
        # Max tau we care about
        my $maxt = $n / $nf->[-1][0];

        # Max factors in a factorization of maxt
        my $cp = (sum0 map $_->[1], @$nf) - 1;

        # Max allocations for an element (number of odd prime factors)
        my $cop = $cp + 1 - $nf->[0][1];

        # Max total allocations (excluding the current one)
        my $max_alloc = $cop * $k - 1;

        # We need at most 1 per factor of a factorization, plus 1 for
        # each allocation, plus 1 per forced prime (which can be used
        # without filling a normal allocation).
        my $need = $cp + $max_alloc + prime_count($forcep);
        @p = nprimes($need, 0);

        # Forced primes are always allocated, so never part of mintau.
        @p = grep $_ > $forcep, @p;

        # A prime p allocated at i + xp is not suppressed at i.
        $smallp{$_} = 1 for grep $_ < $k, @p;

        # Prepare all possible mintau() for all relevant tau
        $mint[$_] = fill_mintau($_, \@p) for divisors($maxt);
        return;
    }
    #
    # Return the least m such that tau(m) = $tau, avoiding the primes p
    # that have defined values in %used.
    #
    sub mintau {
        my($tau, $i) = @_;
        # create bit-vector of primes to suppress
        my $vec = 0;
        for my $j (0 .. $#p) {
            my $p = $p[$j];
            $vec |= (1 << $j) if defined $used{$p};
        }
        for (@{ $mint[$tau] // die "no mint found for $tau" }) {
            my($ok, $r) = @$_;
            return $r if ($ok & $vec) == 0;
        }
        die "no mint match found for $vec at t=$tau";
    }
}

sub recover {
    my($runid) = @_;
    my $r = $db->resultset('Run')->find({ runid => $runid })
            // die "cannot find Run entry for runid=$runid";
    die "Run with runid=$runid is already complete"
            if $r->complete;
    die "Run with runid=$runid is not owned"
            unless $r->owner == 1;
    my $path = $r->logpath($type);
    print "path $path\n";
    open(my $rfh, '<', $path)
            or die "Cannot open $path: $!";
    my $head = <$rfh>;
    $head =~ m{
        ^ 001 \s+ oul\( (\d+) \s+ (\d+) \)
        (?: \s+ -p(\d+) )?
        (?: \s+ -g(\d+) )?
        (?: \s+ -s(\d+) )?
        (?: \s+ -x(\d+) )?
        $
    }x or die "Cannot parse header for $path: $head";
    ($n, $k) = ($1, $2);
    $cap = $3 if $3;
    $gain //= $4 if $4; # allow caller to override
    $start = $5 if defined $5;
    $max //= $6 if $6; # allow caller to override

    my $pos = tell $rfh;
    my $trunc = 0;
    my %log;
    while (my $log = <$rfh>) {
        # detect garbage at end of file
        $trunc = 1, last if $log =~ /^\x{0}/ || $log !~ /\n\z/;
        die "Could not parse log line in $path: $log"
                unless $log =~ /^(\d{3})\b/;
        $log{$1} = $log;    # keep just the last of each type
        $pos = tell $rfh;
    }
    close $rfh;

    my $progress;
    for my $which (keys %log) {
        if ($which eq '305') {
            $progress = $log{$which};
        } elsif ($which eq '202') {
            $log{$which} =~ m{
                ^ 202 \s+ Candidate \s+ (\d+) \s+ \(\d+\.\d+s\) $
            }x or die "Could not parse 202 line in $path: $log{$which}";
            unless ($max && $max < $1) {
                $max = MBI($1);
                $seen_best = 1;
            }
        } elsif ($which eq '001') {
            # previous recovery is ok
        } elsif ($which eq '000') {
            # comments are ok
        } else {
            die "Unexpected log line in $path: $log{$which}";
        }
    }
    die "No 305 line found to recover from in $path"
            unless $progress;
    $progress =~ m{
        ^ 305 ( (?:
            \s+ \.
        |
            \s+ \d+ (?: \^ \d+ )?
            (?: \. \d+ (?: \^ \d+ )? )*
        ){$k} )
        (?: : \s+ (?:
            t=1 (?# ignore )
        |
            (\d+) \s+ / \s+ (\d+)
        ) )?
        \s+ \( (\d+\.\d+) s \)
        $
    }x or die "Could not parse 305 line in $path, k=$k: $progress";
    my($stack, $walk_from, $walk_to, $time) = ($1, $2, $3, $4);
    $stack =~ s/^\s+//;
    @rstack = map {
        $_ eq '.' ? [] : [ map [ split /\^/ ], split /\./ ]
    } split /\s+/, $stack;
    $_->[1] //= 1 for map @$_, @rstack;
    $rwalk = $walk_from;
    $t0 -= $time;
    $inject = 1;

    truncate($path, $pos) if $trunc;
    open(my $wfh, '>>', $path) or die "$path: $!";
    $wfh->autoflush(1);
    return($r, $wfh);
}

sub prep_run {
    my($n, $k, $complete) = @_;
    my $g = g();
    my $f = Seq::TauF->forceFor($g, $db, $k);
    my $r = Seq::Run->gen($f, $db, {
        optn => $zero,
        optx => $zero,
        optc => $gain,
        priority => 0,
    });
    $r->partial(1) unless $complete;
    $r->running(1);
    $r->update;
    my $path = $r->logpath($type);
    print "path $path\n";
    open(my $fh, '>', $path) or die "$path: $!";
    $fh->autoflush(1);
    return ($r, $fh);
}

sub finish_run {
    report(sprintf <<OUT, $gain, $n, $k, $countr, $countw, times() - $t0);
367 oul -g%s %s %s: recurse %s, walk %s (%.2fs)
OUT
    goto finish_fail unless $seen_best;

    my $checked = report_seq($n, $k, $best);
    if ($checked) {
        report(sprintf <<OUT, $n, $k, $best);
265 check ok f(%s, %s) = %s
OUT
    } else {
        report(sprintf <<OUT, $n, $k, $best, times() - $t0);
565 check not ok f(%s, %s) != %s (%.2fs)
OUT
    }

    unless ($nodb) {
        my $g = g();
        my $f = f();
        if ($f->complete) {
            if ($f->f == $best) {
                report(sprintf <<OUT, $n, $k, $best);
266 db ok f(%s,%s) = %s
OUT
            } else {
                report(sprintf <<OUT, $n, $k, $f->f, $best, times() - $t0);
566 db not ok f(%s,%s) = %s, not %s (%.2fs)
OUT
                goto finish_fail;
            }
        } else {
            if ($g->checked < $best) {
                report(sprintf <<OUT, $n, $k, $g->checked, $best);
366 db maybe ok f(%s,%s) ?= %s < %s
OUT
            } else {
                report(sprintf <<OUT, $n, $k. $best, times() - $t0);
566 db not ok f(%s,%s) > %s, not %s (%.2fs)
OUT
                goto finish_fail;
            }
        }
    }

    if ($checked) {
        report(sprintf <<OUT, $n, $k, $best, times() - $t0);
200 f(%s, %s) = %s (%.2fs)
OUT
    }
    if ($inject) {
        close $fh;
        $r->finalize($db);
    }
    return;
  finish_fail:
    if ($inject) {
        close $fh;
        $r->delete;
    }
    exit 1;
}

sub report_seq {
    my($n, $k, $f) = @_;
    my($still_good, $all_good) = (1, 1);
    my @result;
    for (my $i = 0; ($i <= $k) || $still_good; ++$i) {
        my $v = $type->func_value($n, $i, $f);
        my $result = [ $i, $type->func($v), $v, pf($v) ];
        my $is_good = $type->func_matches($i, $result->[1]);
        $still_good = 0 unless $is_good;
        $all_good = 0 if $i < $k && !$is_good;
        push @result, $result;
    }
    my $flen = length($#result);
    my $vlen = length($result[-1][2]);
    my $name = $type->func_name;
    for (0 .. $#result) {
        my $r = $result[$_];
        report(sprintf <<OUT, $flen, @$r[0, 1], $name, $vlen, @$r[2, 3]);
211 Sequence % *s: % 2s = %s(% *s = %s)
OUT
    }
    return $all_good;
}

{
    my $f;
    sub f {
        return $f //= Seq::TauF->forceFor(g(), $db, $k);
    }
}
{
    my $g;
    sub g {
        return $g //= do {
            Seq::TauG->genTo($db, $n);
            $db->resultset('TauG')->find({ n => $n })
                    // die "cannot find TauG entry for n=$n";
        };
    }
}

sub prep_minp {
    # ensure top layer exists
    @minp = map [], 1 .. $k;
    return if $k < 5 || ($n % 3) == 0;

    # suppress 2^x | v_i if x > 2 and (i + 4 < k or i - 4 >= 0)
    my @d = grep $_ > 3, divisors($n);
    for (0 .. $k - 1) {
        next if $_ + 4 >= $k && $_ - 4 < 0;
        @{ $minp[$_] }[@d] = (2) x @d;
    }
    return;
}

{
    #
    # Return an arrayref of all the ways to factorize $n (with its factor_exp
    # optionally provided as $nf) in reverse lexicographic order, each
    # factorization represented as an arrayref of descending factors.
    # Thus factorizations(12) would return [ [12], [6,2], [4,3], [3,2,2] ].
    #
    my %fall;
    sub factorizations {
        my($n, $nf) = @_;
        return $fall{$n} //= do {
            my @f;
            my $fi = factor_iterator($n, $nf);
            while (my $f = $fi->()) {
                push @f, [ @$f ];
            }
            \@f;
        };
    }
}

#
# Return an iterator that returns factorizations one at a time in the
# same order and in the same form as the contents of the arrayref
# returned by factorizations(). Returns undef to signal the end of
# the list.
#
sub factor_iterator {
    my($n, $nf) = @_;
    if ($n == 1) {
        my $done = 0;
        return sub {
            return $done++ ? undef : [];
        };
    }
    $nf //= [ factor_exp($n) ];
    my @f;
    my %p = map +($_->[0] => 1), @$nf;
    return sub {
        unless (@f) {
            @f = ($n);
            return \@f;
        }
        my $prod = $zone;
        $prod *= pop(@f) while @f && $p{$f[-1]};
        return undef unless @f;
        my $prev = pop @f;
        $prod *= $prev;
        1 while $prod % --$prev;
        push @f, $prev;
        $prod /= $prev;
        while (1) {
            if ($prod <= $prev) {
                push @f, $prod;
                last;
            }
            --$prev while $prod % $prev;
            push @f, $prev;
            $prod /= $prev;
        }
        return \@f;
    };
}

sub prep_fact {
    my($n) = @_;
    for my $d (divisors($n)) {
        if (0 == ($d & ($d - 1))) {
            $fullfact{$d} = [ reverse divisors($d) ];
            next;
        }
        my $df = [ factor_exp($d) ];
        my $dp = $df->[-1][0];

        # for a given tau t to satisfy, we'll want to try any divisor of t
        # that is divisible by the highest prime dividing t, ascending order
        $fact{$d} = [ map $dp * $_, divisors($d / $dp) ];

        # if two successive factors can have the same highest prime, we
        # deduplicate by taking them only in ascending order
        if (($n / $d) % $dp == 0) {
            $nofact{$d}{$_} = 1 for grep $_ > $d,
                    map $_ * $dp, divisors($n / ($dp * $d));
        }

        my $d2 = $d / $dp;
        $d2 /= $dp while 0 == $d2 % $dp;
        $fullfact{$d} = [ @{ $fact{$d} }, @{ $fullfact{$d2} } ];
    }
}

sub nprimes {
    my($count, $need_big) = @_;
    my $it = prime_iterator;
    if ($need_big) {
        return map MBI($it->()), 1 .. $count;
    } else {
        return map $it->(), 1 .. $count;
    }
}

sub modinv {
    my($n, $m) = @_;
    return MBI($n)->bmodinv($m);
}

sub tau {
    my($n, $fact) = @_;
    $fact //= [ factor_exp($n) ];
    my $k = 1;
    $k *= $_->[1] + 1 for @$fact;
    return $k;
}

sub _is_tau {
    my($n, $t) = @_;
    my $root;
    return $t & 1 ? do {
        return 0 unless is_power($n, 2, \$root);
        return sqtau($root) == $t;
    } : $t == 2 ? is_prime($n)
    : $t == 4 ? do {
        is_semiprime($n)
            ? !is_power($n, 2)
            : (is_power($n, 3, \$root) && is_prime($root))
    } : (tau($n) == $t);
}

sub sqtau {
    my($n, $fact) = @_;
    $fact //= [ factor_exp($n) ];
    my $k = 1;
    $k *= 2 * $_->[1] + 1 for @$fact;
    return $k;
}

sub xtau {
    my($n, $x, $fact) = @_;
    $fact //= [ factor_exp($n) ];
    my $k = 1;
    $k *= $x * $_->[1] + 1 for @$fact;
    return $k;
}

sub pf {
    my $n = shift;
    return join '.', map {
        $_->[1] == 1 ? $_->[0] : "$_->[0]^$_->[1]"
    } factor_exp($n);
}

sub ston {
    my($s) = @_;
    $s =~ s/,//g;
    $s =~ s{e(\d+)}{"0" x $1}ie;
    return MBI($s);
}

