#!/opt/maths/bin/perl
use warnings;
use strict;
use Math::BigRat;
use Fcntl qw{ SEEK_SET };
use Time::HiRes qw{ time };
use lib 'lib';
use Shape;

my $recover = 0;
while (@ARGV && $ARGV[0] =~ /^-/) {
    my $arg = shift @ARGV;
    last if $arg eq '--';
    goto do_expand if $arg eq '-b';     # pipeline prefix
    goto do_reduce if $arg eq '-a';     # pipeline postfix
    $recover = 1, next if $arg eq '-r';
    die "unknown option '$arg'";
}
my $n = $ARGV[0] || 2;

=head1 Colinear

For a polyomino S, let c(S) be the greatest number of points (at the centre
of the unit squares comprising the shape) that lie on any single line.
Find a(n, k), the number of k-ominoes S with c(S) <= n.

My initial estimate of max(a(5,k)) is in the range 10^9 to 10^11, so we
will write found k-ominoes to a file in a format that lets us use unix
utilities 'sort' and 'uniq' to find the duplicates.

A significant optimization is to associate a bitmap of disallowed points
with each shape, inherited by any child shapes generated from that parent.
We mark any point found to exceed our colinearity limit as disallowed, but
when we extend a shape by adding one of its neighbours we will also mark
the added point as disallowed in the parent, so that further child shapes
derived from it won't attempt to add that same neighbour. This ensures that
if from shape S we find two new shapes S+A and S+B, we will later attempt
to extend the first as S+A+B, but will not also attempt to extend the
second as S+B+A.

This approach is valid only if we handle parent shapes in the same order
they were generated; as such, we include an index in the entries we write,
and after sorting on the canonicalized shape for deduplication (using
a stable sort so that the earliest copy generated is the one retained),
we then sort the deduplicated results again on the index value.

We must also traverse the neighbours in a consistent order, so even
though we use the canonicalized orientation for deduplication we must
retain (or recover) the original orientation for further processing.

=item packing

We want to pack the data as compactly as possible. To that end, we'd
like to:
- write only shape data, with occasional alignment records;
- prefix the sort pipeline with a process that adds index and canonical,
  and strips out alignment records;
- postfix the sort pipeline to strip out the index and canonical again,
  and add a termination record with count and time.

sort(1) allows us to specify a field separator, but uniq(1) does not.
However both support '--zero-terminated' to set the record separator.

For unaligned shape data, I think we need only size, point and disallowed.
That's a three-valued matrix, which we can encode base-3 as 5 locations per
byte. The prefix will need to modify the encoding to avoid 0x20 and either
0x00 or 0x0a, and the postfix can reverse that.

=cut

my $t0 = (times)[0];
my $align_time = 60;    # they are actually quite cheap, could do more
my $recover_struct;
my $k = $recover ? recover() : 1;
while (1) {
    my($ci, $co) = (0, 0);
    my $fi = input_file($k, $recover);
    my $fo = output_file($k, $recover);
    my $align_next = (times)[0] + $align_time;
    # For each unique shape of size one smaller ...
    while (my $src = fetch($fi)) {
        ++$ci;
        if ((times)[0] > $align_next) {
            print $fo $src->aligner($t0);
            $align_next = (times)[0] + $align_time;
        }
        # Find neighbours of this shape that satisfy colinearity constraint;
        # mark each failing neighbour as always disallowed, for this shape
        # and any children.
        my @good = map {
            $src->colinear(@$_) <= $n
                ? ($_)
                : do { $src->disallow(@$_); () }
        } $src->neighbours;
        # For each of the good neighbours, create the new shape, and mark
        # the new point disallowed for future children of the source -
        # this avoids adding points (B, A) when we already add (A, B).
        for my $point (@good) {
            my $next = $src->add_new(@$point);
            $src->disallow(@$point);
            print $fo $next->writable;
            ++$co;
        }
    }
    print $fo Shape->end_writable($t0);
    close($fo);
    close($fi) unless ref($fi) eq 'ARRAY';
    # Number read of size k-1 is deduplicated count; number written of
    # size k is with duplicates.
    printf "a(%s, %s) read %s, wrote %s (%.2f)\n",
            $n, $k, $ci, $co, (times)[0] - $t0;
    last unless $co;
    ++$k;
}
exit 0;

do_expand:
{
    my $index = 0;
    while (<STDIN>) {
        next if /^A/;
        if (/^E/) {
            print "$index $_";
            exit 0;
        }
        chomp;
        my $s = Shape->parse($_);
        printf "%s %s %s\n", $index++, $_, $s->canonical;
    }
    die "No terminator seen in expand\n";
}

do_reduce:
{
    my $pre_time = $ARGV[0];
    my $index = 0;
    while (<STDIN>) {
        my @f = split ' ';
        if ($f[1] eq 'E') {
            my $time = time() - $pre_time + $f[2];
            printf "E %s %.2f\n", $index, time() - $pre_time + $f[2];
            exit 0;
        }
        print "$f[1]\n";
        ++$index;
    }
    die "No terminator seen in reduce\n";
}

sub logpath {
    my($i) = @_;
    return sprintf 'log/r%d.%d', $n, $i;
}

# Check the log files in ordered pairs, unsorted and sorted.
# For any non-empty unsorted file not ending with a valid terminator,
# determine the restart point from the last complete line and continue
# from there.
# For any non-empty sorted file not ending with a valid terminator,
# remove the file and redo the sort.
# Else continue from the point of the first missing file.
sub recover {
    my $i = 1;
    while (1) {
        return $i if recover_u($i);
        if (recover_s($i)) {
            make_sorted($i);
            return $i + 1;
        }
        ++$i;
    }
}

sub last_line {
    my($path, $align) = @_;
    return undef unless -e $path;
    open my $fi, '<', $path or die "$path: $!";
    my $size = (stat($fi))[7];
    my($term_off, $line_off);
    goto LAST_LINE_FAIL if $size == 0;
    my $buf = '';
    my $off = $size;
    my $block_size = 4096;
    my $rsize;
    while (!defined $line_off) {
        ($rsize, $off) = ($off < $block_size)
            ? ($off, 0)
            : ($block_size, $off - $block_size);
        seek($fi, $off, SEEK_SET) or die "seek $fi $off: $!";
        my $r;
        my $got = read($fi, $r, $rsize);
        die "read $rsize from $off in $path got $got: $!"
                if $got < $rsize;
        unless ($term_off) {
            if (substr($r, -1, 1) eq "\n") {
                $term_off = $off + $rsize;
            } elsif ($r =~ /.*(\n)/s) {
                $term_off = $off + $+[1];
            }
        }
        $buf = "$r$buf";
        if ($term_off && $align) {
            while ($buf =~ /.*(\n)(.)/s) {
                if ($2 eq 'A' || $2 eq 'E') {
                    $line_off = $off + $+[1];
                    last;
                } else {
                    $term_off = $off + $+[1];
                    $buf = substr($buf, 0, $term_off - $off);
                }
            }
        } else {
            $line_off = $off + $+[1] if $term_off && $buf =~ /.*(\n)./s;
        }
        $line_off = 0 if !defined($line_off) && $off == 0;
    }
  LAST_LINE_FAIL:
    close $fi;
    if (!defined $term_off) {
        # no valid data found
        unlink($path);
        return undef;
    }
    if ($align && $term_off < $size) {
        truncate($path, $term_off) or die "truncate $path to $term_off: $!";
    }
    return (defined $term_off)
        ? +(substr($buf, $line_off - $off, $term_off - $line_off), $line_off)
        : undef;
}

sub recover_u {
    my($i) = @_;
    my $ip = logpath($i);
    print "checking $ip\n";
    my($last, $off) = last_line($ip, 1);
    print("  no line found, continuing from here\n"),
            return 1 unless defined $last;
    if ($last =~ /^E ([\d.]+)$/) {
        my $time = $1;
        print "  completed at $time\n";
        # if an unsorted file was complete with index 0, we're all done
        print("nothing to do\n"), exit 0 if $off == 0;
        $t0 = (times)[0] - $time;
        return 0;               # this part was complete
    }
    chomp $last;
    print "  aligner found, continuing from $last\n";
    $recover_struct = Shape->parse_recover($last, $i, \&fetch_parent);
    return 1;
}

sub recover_s {
    my($i) = @_;
    my $ip = logpath($i) . 's';
    print "checking $ip\n";
    my($last) = last_line($ip, 0);
    if (defined($last) && $last =~ /^E (\d+) ([\d.]+)$/) {
        my($count, $time) = ($1, $2);
        print "  completed at $time with $count records\n";
        $t0 = (times)[0] - $time;
        return 0;
    }
    print("  no terminator found, continuing from here\n"),
            return 1 unless defined $last;
    unlink($ip);
    return 1;
}

sub make_sorted {
    my($k) = @_;
    unlink logpath($k + 1);
    my $f = logpath($k);
    my $fs = "${f}s";
    die "$f: no file found" unless -e $f;
    # The data has 3 fields: index, data, canonical.
    # We sort first on the canonical so that we can uniq on it, with
    # sort stability so that the occurrence with earliest index is kept;
    # then re-sort (numerically) by index.
    my $pre_time = time();
    system(sprintf
        './colinear -b <%s'
            . ' | sort --stable --key=3,3'
            . ' | uniq --skip-fields=2'
            . ' | sort --key=1n'
            . ' | ./colinear -a %.2f >%s',
        $f, $pre_time, $fs
    );
    $t0 -= time() - $pre_time;
    return;
}

sub input_file {
    my($k) = @_;
    # handle input of size 0 specially
    return [0] if $k == 1;
    if ($recover_struct) {
        my($fi, $time) = delete @$recover_struct{qw{ fi time }};
        $t0 = (times)[0] - $time;
        return $fi;
    }
    make_sorted($k - 1);
    my $fs = logpath($k - 1) . 's';
    open my $fi, '<', $fs or die "$fs: $!";
    return $fi;
}

sub output_file {
    my($k) = @_;
    my $f = logpath($k);
    open my $fh, '>>', $f or die "$f: $!";
    return $fh;
}

sub fetch {
    my($fh) = @_;
    if (ref($fh) eq 'ARRAY') {
        return undef if $fh->[0]++;
        return Shape->new_empty;
    }
    if ($recover_struct) {
        my $shape = $recover_struct->{shape};
        $recover_struct = undef;
        return $shape;
    }
    my $off = tell($fh);
    my $line = <$fh> // die "Reached end without terminator";
    return undef if $line =~ /^E/;
    return Shape->parse($line, $off);
}

sub fetch_parent {
    my($i, $off, $struct) = @_;
    my $pi = logpath($i - 1) . 's';
    open my $fi, '<', $pi or die "$pi: $!";
    seek($fi, $off, SEEK_SET) or die "seek $pi $off: $!";
    $struct->{fi} = $fi;
    return <$fi> // die "read $pi $off: $!";
}

__END__

a(n) (A380991) = [1, 4, 15, 48, ...]
a(3, k) (A378169) = [
    1, 1, 2, 4, 9, 18, 37, 62,
    86, 78, 61, 34, 14, 4, 1, 0
]
a(4, k) (A380990) = [
    1, 1, 2, 5, 11, 31, 85, 262,
    764, 2255, 6341, 17221, 43994, 106205, 239367, 502611,
    977791, 1771624, 2989373, 4687803, 6819069, 9234529, 11622453, 13527854,
    14571011, 14643347, 13747913, 12041014, 9905945, 7763985, 5805906, 4139266,
    2858796, 1971455, 1368967, 942226, 618148, 368480, 186275, 73649,
    20236, 3476, 400, 96, 27, 12, 2, 1,
    0
]
a(5, k) = [
    1, 1, 2, 5, 12, 34, 104, 339,
    1133, 3845, 13080, 44374, 149495, 
    ...
]

number of polyominoes (A000105) = [
    1 1 2 5 12 35 108 369
    1285 4655 17073 63600 238591 901971 3426576 13079255
    50107909 192622052 742624232 2870671950 11123060678 43191857688 168047007728 654999700403
    2557227044764 9999088822075 39153010938487 153511100594603 602621953061978 2368347037571252 9317706529987950 36695016991712879
    144648268175306702 570694242129491412 2253491528465905342 8905339105809603405 35218318816847951974 139377733711832678648 551961891896743223274 2187263896664830239467
    8672737591212363420225 34408176607279501779592 136585913609703198598627 542473001706357882732070 2155600091107324229254415 8569720333296834568434605 34085105553123831158180217 135629410647775553284438364
    539916438668093786698843965 2150182610161041739167164220 8566301646855786503391647670 34140832502065121824070942627 136116710694919148806231527457 542874683702992552434145546370 2165873377717239478407665345440 8643839320316615721187562237534
    34507662858721137395351058631991 137801831798576866546096116428465 550453451340976338599795923539996
]

peak a(3,k) at k= 9 is A105(k)^0.6222
peak a(4,k) at k=26 is A105(k)^0.5512

% ./colinear 4
a(4, 1) read 1, wrote 1 (0.00)
a(4, 2) read 1, wrote 4 (0.00)
a(4, 3) read 1, wrote 6 (0.00)
a(4, 4) read 2, wrote 14 (0.00)
a(4, 5) read 5, wrote 32 (0.02)
a(4, 6) read 11, wrote 67 (0.05)
a(4, 7) read 31, wrote 175 (0.17)
a(4, 8) read 85, wrote 442 (0.53)
a(4, 9) read 262, wrote 1254 (1.92)
a(4, 10) read 764, wrote 3359 (6.77)
a(4, 11) read 2255, wrote 9052 (21.23)
a(4, 12) read 6341, wrote 23412 (57.71)
a(4, 13) read 17221, wrote 57929 (157.21)
a(4, 14) read 43994, wrote 135339 (451.99)
a(4, 15) read 106205, wrote 298597 (1361.41)
a(4, 16) read 239367, wrote 614277 (3368.89)
a(4, 17) read 502611, wrote 1178319 (7598.50)

