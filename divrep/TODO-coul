FIXME:
- recovery (insert_stack()) has bit-rotted
  - set secondary levels[i] values for unforced primes
  - check setup at the derecurse reentry point (with rwalk)
  - check setup at the top-of-loop reentry point (without rwalk)

TODO (high priority):
- calculate more accurate mintau()
- test "other" tau cases in parallel, one factor_one() step at a time
- tweak optimization options in the Makefile

CHECKME:
- inject failures can clash with walk_1() successes
- random seeding in _GMP_init may stop us getting consistent timings
- after parallelization, check if picking out semiprimes can help us
- can best_v do better by picking the most constrained?

TODO (lower priority):
- stash walk_1 values in an array, test in order (and in parallel)
- maintain a dummy alloc[0] on values[], to save lots of special handling
  - this may remove the need for m[] and t[] in walk_v()
- special case Pell in walk_v
- cache max prime used to short-circuit "used" check
  - use it also to implement minp
- on recover, parse 001 line to check consistency of critical options
- check_residue can be much faster in (almost?) all cases
- reimplement small_divmod()
- reimplement next_prime()
- cater for end value > 2^64 in walk_v, if needed
- add support for -o
  - build it over parallel is_tau() checks, so it can be configurable
- prep the simple_valuation() checks for apply_batch()
- for unforced primes, do constant apply_alloc() work in advance
- avoid recursing when best_v() will find nothing
- check if we can speed up has_sqrtmod()
- for cases like n=54, t=54 we should disallow eg x=9, since we will already
  have tried all x=3 and x=6 before that
- work out how to get the Math::Prime::Util::GMP code we need more portably
- new option to show fixed-prime patterns, with indices
- sharding by new option to select one or more fixed-prime patterns by index
