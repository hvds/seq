#!/opt/maths/bin/perl
use strict;
use warnings;
use Math::GMP;
use Math::Prime::Util qw{ factor_exp prime_iterator divisors };
use Math::Prime::Util::GMP qw{ chinese };
use Syntax::Keyword::Dynamically;
use List::Util qw{ first sum0 all };
use Algorithm::Loops qw{ NestedLoops };
use DDP;    # exports p, np
use lib 'lib';
use Type;
use Seq::Db;
use ModFunc qw/ gcd /;

local $SIG{FPE} = sub { use Carp; confess("Division by zero") };

=head1 oul - constrain upper limit of oneseq(n, k)

Try to find the parameters most likely to get a hit.

=cut

sub MBI { return Math::GMP->new(@_) }
my $zero = MBI(0);
my $zone = MBI(1);

my($max, $start, $inject, $confirm, $debug) = (0) x 5;
my $gain = 1;
my $typename = 'o';
my $maxproc = 6;

while (@ARGV && $ARGV[0] =~ /^-/) {
    my $arg = shift @ARGV;
    last if $arg eq '--';
    ($max = $arg || shift(@ARGV)), next if $arg =~ s{^-x}{};
    ($start = $arg || shift(@ARGV)), next if $arg =~ s{^-s}{};
    ($gain = $arg || shift(@ARGV)), next if $arg =~ s{^-g}{};
    $inject = 1, next if $arg eq '-i';
    $confirm = 1, next if $arg eq '-c';
    ++$debug, next if $arg eq '-d';
    die "Unknown option '$arg'\n";
}

$| = 1;
my($n, $k) = @ARGV;
$0 = "oul($n $k)";
my $type = Type->new($typename);
$type->bind($n);
$type->bind_owner('upperlim');
my $db = Seq::Db->new($type, 0);

my $nf = [ factor_exp($n) ];
my $tn = tau($n, $nf);
my(%fact, %nofact);
prep_fact($n);
prep_mintau();

my($diag_delay, $log_delay) = (1, 600);
my $t0 = scalar times();
my($diagt, $logt) = ($t0 + $diag_delay, $t0 + $log_delay);

my $min = g()->checked;     # not currently used
$max = ston($max) if $max;
$max = f()->f if $confirm;

# Note that if we run with $max set to a non-solution, and we fail to find
# a solution, this will finish by reporting a bad solution rather than
# "no solution found".
my $best = $max || undef;
my $have_best = $best ? 1 : 0;

# Always true for now; the intention is to set it false for a partial run,
# mainly to ensure the flag is set on the Run object.
my $complete = 1;

# Lookup of primes allocated so far, that should be avoided
my %used;

#
# Elements v[0..k-1] represent the composition of the value d+i that
# we're trying to build up. Each element is a hashref of:
#   p[] => primes we've allocated to the factors
#   pu{} => lookup of primes in p[]
#   x[] => the power we've raised those primes to
#   q => total value attributed
#   t => tau() not yet accounted for (ie n / tau(q))
#   l => level: how many entries in p[] and x[] are valid
#
my @v = map +{
    p => [], pu => {}, x => [], q => $zone, t => $n, l => 0,
}, 0 .. $k - 1;

# Recursion level
my $level = 0;
# Product of v[i]{q} per recursion level
my @aq = ($zone);

my($countr, $countw) = (0, 0);

my @injected = (0) x $k;

my($r, $fh);
($r, $fh) = prep_run($n, $k, $complete) if $inject;
report(sprintf "001 %s%s%s\n", $0,
        $gain > 1 ? " -g$gain" : "", $max ? " -x$max" : "");
recurse();
finish_run();
exit 0;

# For debugging or sharding: inject assignment of p^x into a_i.
sub inject {
    my($i, $p, $x) = @_;
    my $v = $v[$i];
    my $zp = MBI($p);
    my $l = $v->{l}++;
    $v->{p}[$l] = $zp;
    $v->{pu}{$zp} = 1;
    $v->{x}[$l] = $x;
    $v->{q} *= $zp ** ($x - 1);
    $v->{t} /= $x;
    $used{$p} = $i;
    ++$injected[$i];
    return;
}

{
    my $s; BEGIN { $s = '' }
    sub diag {
        print "\x08 \x08" x length($s);
        ($s) = @_;
        print $s;
        return;
    }
    sub keep_diag {
        if (length $s) {
            print "\n";
            $s = '';
        }
        return;
    }
}

sub report {
    my($msg) = @_;
    print $fh $msg if $fh;
    keep_diag();
    print $msg;
    return;
}

sub do_diag {
    my($msg) = @_;
    diag($msg);
    $diagt = times() + $diag_delay;
    if ($fh && times() >= $logt) {
        print $fh sprintf "305 %s (%.2fs)\n", $msg, times() - $t0;
        $logt = times() + $log_delay;
    }
    return;
}

sub candidate {
    my($new) = @_;
    return unless $new;
    report(sprintf <<OUT, $new, times() - $t0);
202 Candidate %s (%.2fs)
OUT
    unless ($have_best && $best < $new) {
        $best = $new;
        $have_best = 1;
    }
    return;
}

sub desc {
    my($va) = @_;
    return join ' ', map {
        my($p, $x, $l) = @$_{qw{ p x l }};
        join('.', map "$p->[$_]^@{[ $x->[$_] - 1 ]}", 0 .. $l - 1)
                || '.';
    } @$va;
}

sub recurse {
    ++$countr;
    my $i = best_v() // return candidate(walk_v());
    my $v = $v[$i];
    my $fa = $fact{$v->{t}} // return candidate(walk_v());
    my $vlevel = $v->{l};
    my $prex = $vlevel ? $v->{x}[$vlevel - 1] : 0;
  POWER:
    for my $x (@$fa) {
        # CHECKME: for n=54, we should disallow eg x=9 when t=54, since we
        # will already have tried all x=3 and x=6 before that.
        next if $nofact{$x}{$prex} && $vlevel >= $injected[$i];

        # Try to add another factor to this $v. Check all primes if different,
        # or only greater primes if same power as previous power.
        my $p = ($prex == $x) ? $v->{p}[$vlevel - 1] : $zone;
        my $tnext = $v->{t} / $x;
        $v->{x}[$vlevel] = $x;

        # We can get slightly better accuracy by recalculating this each
        # time in the loop below, at least for small $p, but the cost
        # outweighs the benefit.
        my $mint = mintau($tnext, $i);
        if ($have_best) {
            my $lim = (($best + $i) / $v->{q} / $mint)->broot($x - 1);
            next POWER if $lim < $p + 1;
            my $walk = ($best + $i) / $aq[$level];
            candidate(walk_v()), last POWER if $walk * $gain < $lim;
        }

        if ($tnext == 1) {
            my $q = $v->{q};
            while (1) {
                $p = next_zprime($p);
                next if defined $used{$p};
                my $qx = $q * $p ** ($x - 1);
                next POWER if $have_best && $qx > $best;
                my $result = walk_1($i, $qx - $i);
                candidate($result), next POWER if $result;
            }
        }

        local $v->{l} = $v->{l} + 1;
        my($have_pb, $pb) = ($have_best, $best);
        while (1) {
            $p = next_zprime($p);
            next if defined $used{$p};
            local $used{$p} = $i;
            local $v->{pu}{$p} = 1;
            my $px = $p ** ($x - 1);
            $v->{p}[$vlevel] = $p;
            my $q = $v->{q} * $px;
            if ($have_best) {
                if ($q * $mint > $best + $i) {
                    $debug && warn "for $i last at [@{ $v->{p} }] ($q * $mint > $best)\n";
                    last;
                }
                if (!$have_pb || $best < $pb) {
                    ($have_pb, $pb) = ($have_best, $best);
                    my $lim = (($best + $i) / $v->{q} / $mint)->broot($x - 1);
                    next POWER if $lim < $p;
                    my $walk = ($best + $i) / $aq[$level];
                    candidate(walk_v()), last POWER if $walk * $gain < $lim;
                }
            }

            local $v->{t} = $tnext;
            local $v->{q} = $q;
            local $aq[$level + 1] = $aq[$level] * $px;
            ++$level;
            do_diag(desc(\@v)) if times() >= $diagt;
            recurse();
            --$level;
        }
    }
    $#{ $v->{p} } = $vlevel - 1;
    return;
}

sub walk_1 {
    my($i, $val) = @_;
    for (0 .. $#v) {
        next if $_ == $i;
        my $v = $v[$_];
        my($vi, $mod) = ($val + $_)->bdiv($v->{q});
        return undef if $mod;
        return undef if gcd($vi, $v->{q}) != 1;
        return undef if tau($vi) != $v->{t};
    }
    return $val;
}

sub walk_v {
    my @q = map $_->{q}, @v;
    # find m: 2^x | m (mod (2p)^x), 3^x | m+diff (mod (2p)^x)
    my $m = MBI(chinese(map [ -$_, $q[$_] ], 0 .. $#q));
    return if $have_best && $m > $best;

    my @t = map $_->{t}, @v;
    my $aq = $aq[$level];
    my @qq = map $aq / $_, @q;
    my @o = map +($m + $_) / $q[$_], 0 .. $#q;

    #
    # This is the core loop, for long runs we expect to spend the bulk
    # of our time here (probably in factorization for the tau() checks).
    #
    my $end = $have_best ? $best / $q[0] : undef;
    my $endi = ($end // 0) / $qq[0];
    while (!defined($end) || $o[0] <= $end) {
        ++$countw;
        if (times() >= $diagt) {
            my $ati = $o[0] / $qq[0];
            do_diag(desc(\@v) . ": $ati / $endi");
        }

        # Return a solution if we find one. Do the gcd checks first,
        # since they should be much faster than factorization.
        #
        # FIXME: maintain $ati and prepare inverses for each assigned
        # prime so the gcd check becomes a simple integer mod check:
        #   all { $ati % $invp[$_] != $invmod[$_] } 0 .. $#o
        # I think we can safely rely on both $ati and assigned primes
        # not to exceed range of exact integer maths.
        return $o[0] * $q[0] if (
            all { gcd($o[$_], $q[$_]) == 1 } 0 .. $#o
        ) && (
            all { tau($o[$_]) == $t[$_] } 0 .. $#o
        );

        # step the candidates by prod q_i
        $o[$_] += $qq[$_] for 0 .. $#o;
    }
    return;
}


# find the best entry to progress: the one with the highest tau()
# still to fulfil, or (on equality) with the highest q, but having
# at least one factor to allocate.
sub best_v {
    my($i, $vi);
    # FIXME: hack for f(2p,3)
    return $#v >> 1 if $v[$#v >> 1]{l} == 0;
    for my $j (0 .. $#v) {
        my $vj = $v[$j];
        # skip if no odd prime factor
        next unless $fact{$vj->{t}};

        if ($vi) {
            # doesn't have higher tau
            next if $vj->{t} < $vi->{t};
            # doesn't have higher q
            next if $vj->{t} == $vi->{t} && $vj->{q} <= $vi->{q};
        }
        ($i, $vi) = ($j, $vj);
    }
    return $i // undef;
}

# Prepare an element of the @mint array below
sub fill_mintau {
    my($tau, $primes) = @_;
    my @p = map MBI($_), @$primes;
    my(@r, @v);
    return [ [ 0, $zone ] ] if $tau == 1;

    # Find all values over the given primes, and associated bit vectors
    for my $f (@{ factorizations($tau) }) {
        NestedLoops([
            [ 0 .. $#$primes ],
            map sub {
                [ $_[-1] + 1 .. $#$primes ]
            }, 1 .. $#$f
        ], { OnlyWhen => 0 }, sub {
            my $vec = 0;
            my $val = $zone;
            for my $i (0 .. $#_) {
                my $j = $_[$i];
                $vec |= 1 << $j;
                $val *= $p[$j] ** ($f->[$i] - 1);
            }
            push @v, [ $vec, $val ];
        });
    }
    @v = sort { $a->[1] <=> $b->[1] } @v;

    # Repeatedly take best value, then discard any worse values that
    # would use the same primes.
    while (@v) {
        my $v = shift @v;
        push @r, $v;
        my $vec = $v->[0];
        @v = grep +($_->[0] & $vec) != $vec, @v;
    }
    return \@r;
}

{
    # $mint[$t] is an arrayref possible mintau() values for tau=$t.
    # Each entry is an arrayref [ok_vector, value]; this value should be
    # returned if the bit vector of used primes has no bits in common
    # with ok_vector.
    my @mint;

    my @p;
    my %smallp;
    sub prep_mintau {
        # Max tau we care about
        my $maxt = $n / $nf->[-1][0];

        # Max factors in a factorization of maxt
        my $cp = (sum0 map $_->[1], @$nf) - 1;

        # Max allocations for an element (number of odd prime factors)
        my $cop = $cp + 1 - $nf->[0][1];

        # Max total allocations (excluding the current one)
        my $max_alloc = $cop * $k - 1;

        # We need at most 1 per factor of a factorization, plus 1 for
        # each allocation.
        my $need = $cp + $max_alloc;
        @p = nprimes($need, 0);

        # A prime p allocated at i + xp is not suppressed at i.
        $smallp{$_} = 1 for grep $_ < $k, @p;

        # Prepare all possible mintau() for all relevant tau
        $mint[$_] = fill_mintau($_, \@p) for divisors($maxt);
        return;
    }
    #
    # Return the least m such that tau(m) = $tau, avoiding the primes p
    # that have true values in %used (unless they are avoided only
    # because used in some v_$j, such that $j - $i is a multiple of p).
    #
    sub mintau {
        my($tau, $i) = @_;
        # create bit-vector of primes to suppress
        my $vec = 0;
        for my $j (0 .. $#p) {
            my $p = $p[$j];
            my $k = $used{$p} // next;
            my $d = $k - $i;
            $vec |= (1 << $j) if !$d || ($d % $p) != 0;
        }
        for (@{ $mint[$tau] // die "no mint found for $tau" }) {
            my($ok, $r) = @$_;
            return $r if ($ok & $vec) == 0;
        }
        die "no mint match found for $vec at t=$tau";
    }
}

sub prep_run {
    my($n, $k, $complete) = @_;
    my $g = g();
    my $f = Seq::TauF->forceFor($g, $db, $k);
    my $r = Seq::Run->gen($f, $db, {
        optn => $zero,
        optx => $zero,
        optc => $gain,
        priority => 0,
        partial => !$complete,
    });
    $r->running(1);
    $r->update;
    my $path = $r->logpath($type);
    print "path $path\n";
    open(my $fh, '>', $path) or die "$path: $!";
    $fh->autoflush(1);
    return ($r, $fh);
}

sub finish_run {
    report(sprintf <<OUT, $gain, $n, $k, $countr, $countw, times() - $t0);
367 oul -g%s %s %s: recurse %s, walk %s (%.2fs)
OUT
    my $checked = report_seq($n, $k, $best);
    if ($checked) {
        report(sprintf <<OUT, $n, $k, $best);
265 check ok f(%s, %s) = %s
OUT
    } else {
        report(sprintf <<OUT, $n, $k, $best, times() - $t0);
565 check not ok f(%s, %s) != %s (%.2fs)
OUT
    }

    my $g = g();
    my $f = f();
    if ($f->complete) {
        if ($f->f == $best) {
            report(sprintf <<OUT, $n, $k, $best);
266 db ok f(%s,%s) = %s
OUT
        } else {
            report(sprintf <<OUT, $n, $k, $f->f, $best, times() - $t0);
566 db not ok f(%s,%s) = %s, not %s (%.2fs)
OUT
            goto finish_fail;
        }
    } else {
        if ($g->checked < $best) {
            report(sprintf <<OUT, $n, $k, $g->checked, $best);
366 db maybe ok f(%s,%s) ?= %s < %s
OUT
        } else {
            report(sprintf <<OUT, $n, $k. $best, times() - $t0);
566 db not ok f(%s,%s) > %s, not %s (%.2fs)
OUT
            goto finish_fail;
        }
    }

    if ($checked) {
        report(sprintf <<OUT, $n, $k, $best, times() - $t0);
200 f(%s, %s) = %s (%.2fs)
OUT
    }
    if ($inject) {
        close $fh;
        $r->finalize($db);
    }
    return;
  finish_fail:
    if ($inject) {
        close $fh;
        $r->delete;
    }
    exit 1;
}

sub report_seq {
    my($n, $k, $f) = @_;
    my($still_good, $all_good) = (1, 1);
    my @result;
    for (my $i = 0; ($i <= $k) || $still_good; ++$i) {
        my $v = $type->func_value($n, $i, $f);
        my $result = [ $i, $type->func($v), $v, pf($v) ];
        my $is_good = $type->func_matches($i, $result->[1]);
        $still_good = 0 unless $is_good;
        $all_good = 0 if $i < $k && !$is_good;
        push @result, $result;
    }
    my $flen = length($#result);
    my $vlen = length($result[-1][2]);
    my $name = $type->func_name;
    for (0 .. $#result) {
        my $r = $result[$_];
        report(sprintf <<OUT, $flen, @$r[0, 1], $name, $vlen, @$r[2, 3]);
211 Sequence % *s: % 2s = %s(% *s = %s)
OUT
    }
    return $all_good;
}

{
    my $f;
    sub f {
        return $f //= Seq::TauF->forceFor(g(), $db, $k);
    }
}
{
    my $g;
    sub g {
        return $g //= do {
            Seq::TauG->genTo($db, $n);
            $db->resultset('TauG')->find({ n => $n })
                    // die "cannot find TauG entry for n=$n";
        };
    }
}

{
    #
    # Return an arrayref of all the ways to factorize $n (with its factor_exp
    # optionally provided as $nf) in reverse lexicographic order, each
    # factorization represented as an arrayref of descending factors.
    # Thus factorizations(12) would return [ [12], [6,2], [4,3], [3,2,2] ].
    #
    my %fall;
    sub factorizations {
        my($n, $nf) = @_;
        return $fall{$n} //= do {
            my @f;
            my $fi = factor_iterator($n, $nf);
            while (my $f = $fi->()) {
                push @f, [ @$f ];
            }
            \@f;
        };
    }
}

#
# Return an iterator that returns factorizations one at a time in the
# same order and in the same form as the contents of the arrayref
# returned by factorizations(). Returns undef to signal the end of
# the list.
#
sub factor_iterator {
    my($n, $nf) = @_;
    if ($n == 1) {
        my $done = 0;
        return sub {
            return $done++ ? undef : [];
        };
    }
    $nf //= [ factor_exp($n) ];
    my @f;
    my %p = map +($_->[0] => 1), @$nf;
    return sub {
        unless (@f) {
            @f = ($n);
            return \@f;
        }
        my $prod = $zone;
        $prod *= pop(@f) while @f && $p{$f[-1]};
        return undef unless @f;
        my $prev = pop @f;
        $prod *= $prev;
        1 while $prod % --$prev;
        push @f, $prev;
        $prod /= $prev;
        while (1) {
            if ($prod <= $prev) {
                push @f, $prod;
                last;
            }
            --$prev while $prod % $prev;
            push @f, $prev;
            $prod /= $prev;
        }
        return \@f;
    };
}

sub prep_fact {
    my($n) = @_;
    for my $d (divisors($n)) {
        next if 0 == ($d & ($d - 1));   # skip powers of 2
        my $df = [ factor_exp($d) ];
        my $dp = $df->[-1][0];

        # for a given tau t to satisfy, we'll want to try any divisor of t
        # that is divisible by the highest prime dividing t, ascending order
        $fact{$d} = [ map $dp * $_, divisors($d / $dp) ];

        # if two successive factors can have the same highest prime, we
        # deduplicate by taking them only in ascending order
        if (($n / $d) % $dp == 0) {
            $nofact{$d}{$_} = 1 for grep $_ > $d,
                    map $_ * $dp, divisors($n / ($dp * $d));
        }
    }
}

sub next_zprime {
    my($p) = @_;
    my $q = Math::Prime::Util::next_prime($p);
    return MBI($q);
}

sub nprimes {
    my($count, $need_big) = @_;
    my $it = prime_iterator;
    if ($need_big) {
        return map MBI($it->()), 1 .. $count;
    } else {
        return map $it->(), 1 .. $count;
    }
}

sub modinv {
    my($n, $m) = @_;
    return MBI($n)->bmodinv($m);
}

sub tau {
    my($n, $fact) = @_;
    $fact //= [ factor_exp($n) ];
    my $k = 1;
    $k *= $_->[1] + 1 for @$fact;
    return $k;
}

sub pf {
    my $n = shift;
    return join '.', map {
        $_->[1] == 1 ? $_->[0] : "$_->[0]^$_->[1]"
    } factor_exp($n);
}

sub ston {
    my($s) = @_;
    $s =~ s/,//g;
    $s =~ s{e(\d+)}{"0" x $1}ie;
    return MBI($s);
}

