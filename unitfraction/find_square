#!/opt/maths/bin/perl
use strict;
use warnings;
use Math::BigInt qw{ lib GMP };
use Math::BigRat qw{ lib GMP };
use Math::Prime::Util qw{ factor_exp divisors sqrtmod divmod };
use List::Util qw{ first };
use lib '../lib';
use H::Diag qw{ diag keep_diag };
sub usq { return Math::BigRat->new(1, $_[0] * $_[0]) }

my($p, $q) = @ARGV;
my %exclude = map +($_ => 1), @ARGV[2..$#ARGV];
my $r = Math::BigRat->new($p, $q);
print "trying $r\n";
my $max_factors = 1 << 20;

# find min for continuous run
my @sq;
for ($sq[0] = 1; 1; ++$sq[0]) {
    ++$sq[0] while $exclude{$sq[0]};
    my $rmin = usq($sq[0]);
    next if $rmin > $r;
    $r -= $rmin;
    last;
}
print "min $sq[0] leaving $r\n";

# find max for continuous run
while (1) {
    my $i = @sq;
    my $n = $sq[$i - 1] + 1;
    ++$n while $exclude{$n};
    my $rmax = usq($n);
    last if $rmax > $r;
    push @sq, $n;
    $r -= $rmax;
}
print "max $sq[-1] leaving $r\n";

# find divisors of denominator
my $data = {
    r => $r,
    p => $r->numerator,
    q => $r->denominator,
    fq => [ factor_exp($r->denominator) ],
    sq => \@sq,
    max_cont => $sq[-1],
    seen => {},
};
get_root($data);
while (1) {
    if ($data->{factors} <= $max_factors) {
        printf "try %s with root %s (%s factors)\n",
                @$data{qw{ r root factors}};
        last if try_factors($data);
        expand_factors($data);
    } else {
        print "try cast from $data->{factors} factors\n";
        try_cast($data);
    }
}
exit 0;

our(@d, %d);
my @cur;
my $counter; BEGIN { $counter = 0 }
sub try_srg {
    my($targ, $cur, $min, $best) = @_;
diag("t=$targ c=$cur m=$min b=@{[ $best // 'u' ]} [@cur]")
        if (++$counter % 100000) == 0;
    return unless $d[$min];
    my $exact = $d{$targ};
    if ($exact && $exact >= $d[$min][0]) {
        my @all = sort { $a <=> $b } (@sq, @cur, $exact);
        keep_diag();
        print 0+@all, " [@all]\n";
        return [$exact];
    }

    # if not exact, will need at least $cur + 2
    return if defined($best) && $cur + 2 >= $best;

    my $tried;
    for my $this ($min .. $#d) {
        my($d, $v) = @{ $d[$this] };
        next if $v > $targ;
        last if defined($best) && (
            $targ > $v * ($best - $cur - 1)
        );
        local $cur[$cur] = $d;
        my $got = try_srg($targ - $v, $cur + 1, $this + 1, $best)
                // next;
        $tried = [ $d, @$got ];
        $best = @$tried + $cur;
    }
    return $tried;
}

# reset p/q to kp/kq with kq square, find sqrt(kq) and count its factors
sub get_root {
    my($data) = @_;
    my $root = Math::BigInt->new(1);
    my $count = Math::BigInt->new(1);
    my($p, $q) = @$data{qw{ p q }};
    for (@{ $data->{fq} }) {
        my($prime, $exp) = @$_;
        if ($exp & 1) {
            $p *= $prime;
            $q *= $prime;
            ++$exp;
        }
        $_->[1] = $exp >>= 1;
        $root *= $prime ** $exp;
        $count *= $exp + 1;
    }
    @$data{qw{ p q root factors }} = ($p, $q, $root, $count);
    return;
}

sub try_add {
    my($data, $k) = @_;
    return 0 if $k <= $data->{max_cont};
    return 0 if $data->{seen}{$k};
    my $r = usq($k);
    return 0 if $data->{r} < $r;
    $data->{r} -= $r;
    print "push $k giving $data->{r}\n";
    $data->{p} = $data->{r}->numerator;
    $data->{q} = $data->{r}->denominator;
    $data->{fq} = [ factor_exp($data->{q}) ];
    push @{ $data->{sq} }, $k;
    $data->{seen}{$k} = 1;
    get_root($data);
    return 1;
}

# try simple recursive greedy over divisors of root
sub try_factors {
    my($data) = @_;
    my($p, $q, $root) = @$data{qw{ p q root }};
    my $r2 = $root * $root;
    local @d = map [ $_, $r2 / $_ / $_ ], divisors($root);
    local %d = map +($_->[1] => $_->[0]), @d;

    # try simple recursive greedy
    my $best = try_srg($p, 0, 0, undef);
    keep_diag();
    return 0 unless $best;
    my $count = @sq + @$best;
    print "best srg $count [@sq @$best]\n";
    return 1;
}

# reset p/q to k^2p/k^2q so that sqrt(k^2q) is divisible by the least factor
# that doesn't already divide sqrt(q); recalc root and factors
sub expand_factors {
    my($data) = @_;
    my($root) = $data->{root};
    my $n = 2;
    ++$n while ($root % $n) == 0;
    my $p = $n / $root->bgcd($n);
    my $fq = $data->{fq};
    use List::Util qw{ first };
    my $fqi = first { $fq->[$_][0] == $p } 0 .. $#$fq;
    if (defined $fqi) {
        my $exp = ++$fq->[$fqi][1];
        $data->{factors} /= $exp;
        $data->{factors} *= $exp + 1;
    } else {
        push @$fq, [$p, 1];
        $data->{factors} *= 2;
    }
    $data->{root} *= $p;
    my $p2 = $p * $p;
    $data->{p} *= $p2;
    $data->{q} *= $p2;
    return;
}

# reduce factors in root by casting out the highest prime power dividing it
sub try_cast {
    my($data) = @_;
    my($p, $fq, $root) = @$data{qw{ p fq root }};
    my(@sq1, @sq2);
    for (@{ $data->{fq} }) {
        my($prime, $exp) = @$_;
        my $v = $prime ** $exp;
        my $p2 = $prime * $prime;
        my $sq = sqrtmod($p % $p2 , $p2);
        if ($sq) {
            # only if there's a root _and_ it's non-zero
            push @sq1, [ $prime, $exp, $v, $sq ];
        } else {
            push @sq2, [ $prime, $exp, $v ];
        }
    }
    @sq1 = sort { $a->[2] <=> $b->[2] } @sq1;
    @sq2 = sort { $a->[2] <=> $b->[2] } @sq2;
    my($i1, $i2) = ($#sq1, $#sq2);
  retry_cast:
    if ($i1 >= 0) {
        # try to find a value we can inject that satisfies the biggest element
        # of @sq1: given target a/b^2 with b = xyp^e, we want
        # a/b^2 - 1/(xp^e)^2 = a'/c^2: p^e \| c. So we need a = y^2.
        my($p1, $e1, $v1, $ym) = @{ $sq1[$i1] };
        my $p2 = $p1 * $p1;
        my $xy = $root / $v1;
        my $xm = divmod($xy, $ym, $p2);
        my $xm2 = $p2 - $xm;
        ($xm, $xm2) = ($xm2, $xm) if $xm > $xm2;
        for (1 .. 1000) {
            for my $x ($xm, grep $p1 != 2, ($xm2)) {
                if (($xy % $x) == 0) {
                    if (try_add($data, $x * $v1)) {
                        my $fq2 = first { $_->[0] == $p1 } @{ $data->{fq} };
                        die "cast failed ($p1:$x)" if $fq2 && $fq2->[1] >= $e1;
                        print "try_cast: cast $p1 via $x * $v1\n";
                        return;
                    } else {
                        print "try_add failed for $x * $v1\n";
                    }
                }
            }
            $_ += $p2 for ($xm, $xm2);
        }
        # failed; try something else
print ".. no match for $p1\n";
        --$i1;
        goto retry_cast;
    } elsif ($i2 >= 0) {
        my($p2, $e2, $v2) = @{ $sq2[$i2] };
        die "todo: try_cast single sq2 [$p2^$e2=$v2]\n";
    }
    die "try_cast: nothing left to try\n";
}
