#!/opt/maths/bin/perl
use warnings;
use strict;
use Math::BigRat;
use Fcntl qw{ SEEK_SET };
use lib 'lib';
use Shape;

my $recover = 0;
while (@ARGV && $ARGV[0] =~ /^-/) {
    my $arg = shift @ARGV;
    last if $arg eq '--';
    $recover = 1, next if $arg eq '-r';
    die "unknown option '$arg'";
}
my $n = $ARGV[0] || 2;

=head1 Colinear

For a polyomino S, let c(S) be the greatest number of points (at the centre
of the unit squares comprising the shape) that lie on any single line.
Find a(n, k), the number of k-ominoes S with c(S) <= n.

My initial estimate of max(a(5,k)) is in the range 10^9 to 10^11, so we
will write found k-ominoes to a file in a format that lets us use unix
utilities 'sort' and 'uniq' to find the duplicates.

A significant optimization is to associate a bitmap of disallowed points
with each shape, inherited by any child shapes generated from that parent.
We mark any point found to exceed our colinearity limit as disallowed, but
when we extend a shape by adding one of its neighbours we will also mark
the added point as disallowed in the parent, so that further child shapes
derived from it won't attempt to add that same neighbour. This ensures that
if from shape S we find two new shapes S+A and S+B, we will later attempt
to extend the first as S+A+B, but will not also attempt to extend the
second as S+B+A.

This approach is valid only if we handle parent shapes in the same order
they were generated; as such, we include an index in the entries we write,
and after sorting on the canonicalized shape for deduplication (using
a stable sort so that the earliest copy generated is the one retained),
we then sort the deduplicated results again on the index value.

We must also traverse the neighbours in a consistent order, so even
though we use the canonicalized orientation for deduplication we must
retain (or recover) the original orientation for further processing.

=cut

my $t0 = (times)[0];
my $recover_struct;
my $k = $recover ? recover() : 1;
while (1) {
    my($fi, $ci, $co) = input_file($k, $recover);
    my $fo = output_file($k, $recover);
    # For each unique shape of size one smaller ...
    while (my $src = fetch($fi)) {
        ++$ci;
        # Find neighbours of this shape that satisfy colinearity constraint;
        # mark each failing neighbour as always disallowed, for this shape
        # and any children.
        my @good = map {
            $src->colinear(@$_) <= $n
                ? ($_)
                : do { $src->disallow(@$_); () }
        } $src->neighbours;
        # For each of the good neighbours, create the new shape, and mark
        # the new point disallowed for future children of the source -
        # this avoids adding points (B, A) when we already add (A, B).
        for my $point (@good) {
            my $next = $src->add_new(@$point);
            $src->disallow(@$point);
            # We check duplicates on read, not on write.
            write_new($fo, $next, $point, $co);
            ++$co;
        }
    }
    print $fo Shape->end_writable($co, $t0);
    close($fo);
    close($fi) unless ref($fi) eq 'ARRAY';
    # Number read of size k-1 is deduplicated count; number written of
    # size k is with duplicates.
    printf "a(%s, %s) = %s, wrote %s new (%.2f)\n",
            $n, $k - 1, $ci, $co, (times)[0] - $t0;
    print("a($n, $k) = 0\n"), last if $co == 0;
    ++$k;
}
exit 0;

sub logpath {
    my($i) = @_;
    return sprintf 'log/r%d.%d', $n, $i;
}

# Check the log files in ordered pairs, unsorted and sorted.
# For any non-empty unsorted file not ending with a valid terminator,
# determine the restart point from the last complete line and continue
# from there.
# For any non-empty sorted file not ending with a valid terminator,
# remove the file and redo the sort.
# Else continue from the point of the first missing file.
sub recover {
    my $i = 1;
    while (1) {
        return $i if recover_u($i);
        if (recover_s($i)) {
            make_sorted($i);
            return $i + 1;
        }
        ++$i;
    }
}

sub last_line {
    my($path, $trunc) = @_;
    return undef unless -e $path;
    open my $fi, '<', $path or die "$path: $!";
    my $size = (stat($fi))[7];
    my($term_off, $line_off);
    goto LAST_LINE_FAIL if $size == 0;
    my $buf = '';
    my $off = $size;
    my $block_size = 4096;
    while (!defined $line_off) {
        my($rsize, $off) = ($off < $block_size)
            ? ($off, 0)
            : ($block_size, $off - $block_size);
        seek($fi, $off, SEEK_SET) or die "seek $fi $off: $!";
        my $r;
        my $got = read($fi, $r, $rsize);
        die "read $rsize from $off in $path got $got: $!"
                if $got < $rsize;
        unless ($term_off) {
            if (substr($r, -1, 1) eq "\n") {
                $term_off = $off + $rsize;
            } elsif ($r =~ /.*(\n)/s) {
                $term_off = $off + $+[1];
            }
        }
        $buf = "$r$buf";
        $line_off = $off + $+[1] if $term_off
                && substr($buf, 0, $term_off - $off - 1) =~ /.*(\n)/s;
        $line_off //= 0 if $off == 0;
    }
  LAST_LINE_FAIL:
    close $fi;
    if (!defined $term_off) {
        # no valid data found
        unlink($path);
        return undef;
    }
    if ($term_off < $size) {
        truncate($path, $term_off) or die "truncate $path to $term_off: $!";
    }
    return (defined $term_off)
        ? substr($buf, $line_off - $off, $term_off - $line_off)
        : undef;
}

sub recover_u {
    my($i) = @_;
    my $ip = logpath($i);
    my $last = last_line($ip, 1) // return 1;
    if ($last =~ /^(\d+) ([\d.]+) end$/) {
        my($count, $time) = ($1, $2);
        printf "${i}_u $count\n";
        # if an unsorted file was complete with index 0, we're all done
        warn("nothing to do\n"), exit 0 unless $count;
        $t0 = (times)[0] - $time;
        return 0;               # this part was complete
    }
    $recover_struct = Shape->parse_recover($last, $i, \&fetch_parent);
    return 1;
}

sub recover_s {
    my($i) = @_;
    my $ip = logpath($i) . 's';
    my $last = last_line($ip, 0) // return 1;
    if ($last =~ /^0 ([\d.]+) end$/) {
        my $time = $1;
        printf "${i}_s complete\n";
        $t0 = (times)[0] - $time;
        return 0;
    }
    unlink($ip);
    return 1;
}

sub make_sorted {
    my($k) = @_;
    unlink logpath($k);
    my $f = logpath($k - 1);
    my $fs = "${f}s";
    die "$f: no file found" unless -e $f;
    # The data has 3 fields: index, data, canonical.
    # We sort first on the canonical so that we can uniq on it, with
    # sort stability so that the occurrence with earliest index is kept;
    # then re-sort (numerically) by index.
    my $pre_time = (times)[2];
    system(sprintf
        'sort --stable --key=3,3 <%s'
            . ' | uniq --skip-fields=2'
            . ' | sort --key=1n >%s',
        $f, $fs
    );
    $t0 -= (times)[2] - $pre_time;
    open my $fo, '>>', $fs or die "$fs: $!";
    print $fo Shape->end_writable(0, $t0);
    close $fo;
}

sub input_file {
    my($k) = @_;
    # handle input of size 0 specially
    return +([0], 0, 0) if $k == 1;
    if ($recover_struct) {
        my($fi, $ci, $co, $time) = delete @$recover_struct{qw{ fi ci co time }};
        $t0 = (times)[0] - $time;
        return +($fi, $ci, $co);
    }
    make_sorted($k);
    my $fs = logpath($k - 1) . 's';
    open my $fi, '<', $fs or die "$fs: $!";
    return +($fi, 0, 0);
}

sub output_file {
    my($k) = @_;
    my $f = logpath($k);
    open my $fh, '>>', $f or die "$f: $!";
    return $fh;
}

sub write_new {
    my($fh, $s, $point, $index) = @_;
    print $fh $s->writable($point, $index, $t0);
    return;
}

sub fetch {
    my($fh) = @_;
    if (ref($fh) eq 'ARRAY') {
        return undef if $fh->[0]++;
        return Shape->new_empty;
    }
    if ($recover_struct) {
        my $shape = $recover_struct->{shape};
        $recover_struct = undef;
        return $shape;
    }
    my $off = tell($fh);
    my $line = <$fh> // die "Reached end without terminator";
    return undef if $line =~ /end$/;
    return Shape->parse($line, $off);
}

sub fetch_parent {
    my($i, $off, $struct) = @_;
    my $pi = logpath($i - 1) . 's';
    open my $fi, '<', $pi or die "$pi: $!";
    seek($fi, $off, SEEK_SET) or die "seek $pi $off: $!";
    $struct->{fi} = $fi;
    return <$fi> // die "read $pi $off: $!";
}

__END__

a(n) (A380991) = [1, 4, 15, 48, ...]
a(3, k) (A378169) = [
    1, 1, 2, 4, 9, 18, 37, 62,
    86, 78, 61, 34, 14, 4, 1, 0
]
a(4, k) (A380990) = [
    1, 1, 2, 5, 11, 31, 85, 262,
    764, 2255, 6341, 17221, 43994, 106205, 239367, 502611,
    977791, 1771624, 2989373, 4687803, 6819069, 9234529, 11622453, 13527854,
    14571011, 14643347, 13747913, 12041014, 9905945, 7763985, 5805906, 4139266,
    2858796, 1971455, 1368967, 942226, 618148, 368480, 186275, 73649,
    20236, 3476, 400, 96, 27, 12, 2, 1,
    0
]
a(5, k) = [
    1, 1, 2, 5, 12, 34, 104, 339,
    1133, 3845, 13080, 44374, 149495, 
    ...
]

number of polyominoes (A000105) = [
    1 1 2 5 12 35 108 369
    1285 4655 17073 63600 238591 901971 3426576 13079255
    50107909 192622052 742624232 2870671950 11123060678 43191857688 168047007728 654999700403
    2557227044764 9999088822075 39153010938487 153511100594603 602621953061978 2368347037571252 9317706529987950 36695016991712879
    144648268175306702 570694242129491412 2253491528465905342 8905339105809603405 35218318816847951974 139377733711832678648 551961891896743223274 2187263896664830239467
    8672737591212363420225 34408176607279501779592 136585913609703198598627 542473001706357882732070 2155600091107324229254415 8569720333296834568434605 34085105553123831158180217 135629410647775553284438364
    539916438668093786698843965 2150182610161041739167164220 8566301646855786503391647670 34140832502065121824070942627 136116710694919148806231527457 542874683702992552434145546370 2165873377717239478407665345440 8643839320316615721187562237534
    34507662858721137395351058631991 137801831798576866546096116428465 550453451340976338599795923539996
]

peak a(3,k) at k= 9 is A105(k)^0.6222
peak a(4,k) at k=26 is A105(k)^0.5512

% ./colinear 4
a(4, 1) = 1 (0.06)
a(4, 2) = 1 (0.06)
a(4, 3) = 2 (0.06)
a(4, 4) = 5 (0.07)
a(4, 5) = 11 (0.08)
a(4, 6) = 31 (0.12)
a(4, 7) = 85 (0.28)
a(4, 8) = 262 (0.86)
a(4, 9) = 764 (3.14)
a(4, 10) = 2255 (13.20)
a(4, 11) = 6341 (54.36)
a(4, 12) = 17221 (182.10)
a(4, 13) = 43994 (678.54)
a(4, 14) = 106205 (2172.64)
a(4, 15) = 239367 (6276.87)

