#!/opt/maths/bin/perl
use strict;
use warnings;

=head1 A problem on moving stones from K. Knop

Starting with n stones in position 0, a move consists of taking k stones
from position m and moving them to position m+k or position m-k.
a(n) is the least number of moves required to move the n stones to position 1.

In general, a(x+y) <= a(x)+a(y), a(x+1) <= a(x)+1 so a(n) <= n.

Max Alekseyev finds a(0..43) as:
*  0,  1,  2,  3,  4,  5,  5,  6,  7,  7,
*  6,  7,  7,  8,  7,  7,  8,  9,  8,  8,
*  9,  8,  8,  9,  8,  9,  8,  9,  9, 10,
*  9,  9, 10,  9,  9,  9, 10, 10,  9, 10,
*  9, 10,  9, 10
= sum 334

A particular pattern of moves tells us that a(k(km+1)+c) <= 2k+m+f(abs(c),k),
where f(c,k) = A263765(c) when k >= g(c). Using only those patterns, we find:
   0,  1,  2,  3,  4,  5,  5,  6,  7,  7,
   6,  7,  7,  8,  7,  8,  8,  9,  8,  9,
   9,  8,  9, 10, 10,  9, 10, 11, 11, 10,
   9, 10, 11, 11, 10, 11, 10, 11, 11, 10,
  11, 12, 12, 11, 12, 11, 12, 12, 11, 12,
  13, 12, 11, 12, 12, 12, 12, 12, 13, 13,
  13, 12, 13, 14, 13, 13, 13, 13, 12, 13,
  13, 13, 13, 14, 15, 14, 14, 13, 14, 14,
  13, 14, 15, 14, 13, 14, 14, 15, 14, 14,
  15, 15, 15, 14, 15, 15, 14, 15, 15, 15,
  14
= sum 364, 1124
.. which first fails to find optimal solutions at n in {15,19,22,23,24...}.

A second pattern gives a(k(km-1)+c) <= 2k+m-1+f(abs(c),k-1); including
that improves us to:
   0,  1,  2,  3,  4,  5,  5,  6,  7,  7,
   6,  7,  7,  8,  7,  7,  8,  9,  8,  8,
   9,  8,  9,  9,  8,  9, 10, 10,  9, 10,
   9, 10, 10,  9, 10, 11, 10, 10, 11, 10,
  11, 11, 10, 11, 10, 11, 11, 12, 11, 12,
  12, 11, 11, 11, 12, 12, 12, 12, 13, 12,
  11, 12, 12, 13, 12, 13, 13, 13, 12, 12,
  12, 13, 13, 13, 13, 13, 12, 13, 13, 13,
  13, 14, 14, 14, 13, 13, 13, 14, 14, 14,
  14, 14, 13, 14, 14, 13, 14, 15, 15, 14,
  14
= sum 349, 1075
.. with first failures at n in {22,26,27,31,34...}.

Known optimal solutions that beat these patterns are:
a(22)=8: 0:+12, 0:+6, 6:+6, 0:+4, 4:+4, 8:+4, 12:-11, 12:-11;
a(26)=8: 0:+13, 0:+13, 13:-12, 13:-8, 5:-4, 5:-4, 13:-6, 7:-6;
WFL missing 31, 33, 34, 35, 37, 38, 40, 42
a(33)=B3,4,0: +12 +12 +9 +3 +3 +3 -11 -11 -11
a(37)=B3,4,4: +14 +14 +9 +3 +3 +3 -13 -13 -2 -11

Our type-A pattern k(km+1)+c involves moves as follows:
- define the target t=km+1, and a multiset M dependent on c
- move k batches of t+m_i from 0 (k moves)
- move k batches of t+m_i-1 back to 1 (k moves)
- coalesce the remaining k loose stones onto t (f(c,k) moves)
- move these k stones to 1 (m moves)

Our type-B pattern k(km-1)+c involves moves as follows:
- define the target t=km, with the same multiset M as for type A
- move k-1 batches of t+m_i from 0 (k-1 moves)
- move k-1 batches of t+m_i-1 back to 1 (k-1 moves)
- move the remaining batch of (m-1)k from 0 to t (m moves)
- coalesce the remaining t-1 loose stones onto t (f(c,k-1) moves)
- move these t-1 stones to 1 (1 move)

  0   1  44  60  68  71  84 113
113   0   0   0   0   0   0   0
  0   0   0   0   0   0   0 113  #1 +113
  0   0   0   0   0   0  29  84  #2 -29
  0   0   0   0   0  42  29  42  #3 -42
  0   0   0   0   0  84  29   0  #4 -42
  0   0   0   0   0  97  16   0  #5 -13
  0   0   0   0  16  97   0   0  #6 -16
  0   0  27   0  16  70   0   0  #7 -27
  0  70  27   0  16   0   0   0  #8 -70
  0  70  27   8   8   0   0   0  #9 -8
  0  70  27  16   0   0   0   0  #10 -8
  0  70  43   0   0   0   0   0  #11 -16
  0 113   0   0   0   0   0   0  #12 -43
112.113 = 12656
70^2 + 43^2 + 2.42^2 + 29^2 + 27^2 + 2.16^2 + 13^2 + 2.8^2
= 4900 + 1849 + 3528 + 841 + 729 + 512 + 169 + 128 = 12656

=cut

my $limit = 113;
my $c = undef;
my @best = init($limit);
disp(\@best);
while (1) {
    $c = next_c($c);
    find_better($c, \@best);
    disp(\@best, $c);
}
exit 0;

sub find_better {
    my($c, $best) = @_;
    my $tried = 0;
    for (my $k = 1; 1; ++$k) {
        last if $k * ($k + 1) + $c > $limit;
        # type 1: k(km+1)+c
        for (my $m = 1; 1; ++$m) {
            my $n = $k * ($k * $m + 1) + $c;
            last if $n > $limit;
            next if $n < 0;
            ++$tried;
            my $fck = fck($c, $k) // next;
            test($best, $n, $k * 2 + $m + $fck, 0, "A $k $m $c");
        }
        # type 2: k(mk-1)+c
        for (my $m = 1; 1; ++$m) {
            my $n = $k * ($k * $m - 1) + $c;
            last if $n > $limit;
            next if $n < 0;
            ++$tried;
            my $fck = fck($c, $k - 1) // next;
            test($best, $n, $k * 2 + $m - 1 + $fck, 0, "B $k $m $c");
        }
    }
    die "Nothing to try at c=$c\n" unless $tried;
    return;
}

sub test {
    my($best, $n, $fn, $improve, $legend) = @_;
    my $ofn = $best->[$n][0];
    if ($fn > $ofn) {
        return 0;
    } elsif ($fn < $ofn) {
        warn "$n <= $fn improved by $legend\n";
        $best->[$n] = [ $fn, $legend ];
        recalc($best, $n);
        return 1;
    } elsif (!$improve) {
        warn "$n <= $fn also at $legend\n";
        push @{ $best->[$n] }, $legend;
    }
    return 0;
}

sub recalc {
    my($best, $a) = @_;
    my $fa = $best->[$a][0];
    for my $n ($a + 1 .. $limit) {
        my $b = $n - $a;
        my $fb = $best->[$b][0];
        next unless test($best, $n, $fa + $fb, 1, "$a + $b");
        recalc($best, $n);
    }
    return;
}

sub next_c {
    my($prev) = @_;
    return !defined($prev) ? 0
        : ($prev <= 0) ? abs($prev) + 1
        : -$prev;
}

sub disp {
    my($best, $c) = @_;
    my $legend = defined($c) ? sprintf("c =%3d", $c) : " init ";
    my $vals = join '', map sprintf(" %2d,", $_->[0]), @$best;
    warn "$legend: $vals\n";
}

sub init {
    my($lim) = @_;
    return [ 0 ], map [$_, "1+f@{[$_-1]}"], 1 .. $lim;
}

{
    # Let X, Y be multisets of positive integers such that
    # \sum{x_i^2} - \sum{y_i^2} = n. Then f(n) = min(|X| + |Y|), and
    # g(n) = min(max(x_i): |X| + |Y| = f(n)).
    my(@f, @g);
    sub nextf {
        my($c, $max, $lim) = @_;
        return $c ? undef : 0 if $max == 0;
        $lim //= $c;
        return +($c > $lim) ? undef : $c if $max == 1;
        my $known = $f[$c][$max];
        return +($known <= $lim) ? $known : undef if defined $known;
        my $sq = $max * $max;
        my $top = int($c / $sq);
        return undef if $top > $lim;
        my $next = $max - 1;
        my $nextsq = $next * $next;
        my $best = $lim + 1;
        for my $m (reverse 0 .. $top) {
            my $d = $c - $m * $sq;
            last if $d / $nextsq > $lim - $m;
            my $e = (nextf($d, $next, $lim - $m) // next) + $m;
            $best = $e if $best > $e;
        }
        for my $m ($top + 1 .. $lim) {
            my $d = $m * $sq - $c;
            last if $d / $nextsq > $lim - $m;
            my $e = (nextf($d, $next, $lim - $m) // next) + $m;
            $best = $e if $best > $e;
        }
        return undef if $best > $lim;
        return $f[$c][$max] = $best;
    }
    sub firstf {
        my($c) = @_;
        return $f[$c][0] //= do {
            my($f, $g);
            do { ($f, $g) = (0, 0); goto done } if $c == 0;
            my $q = int(sqrt $c);
            # perfect square
            do { ($f, $g) = (1, $q); goto done } if $c == $q * $q;
            my $q2 = sqrt($c / 2);
            $q2 = ($q2 == int($q2)) ? $q2 : (int($q2) + 1);
            for my $qt ($q2 .. $q) {
                my $ct = $c - $qt * $qt;
                my $qu = int(sqrt $ct);
                # sum of two squares
                do { ($f, $g) = (2, $qt); goto done }
                        if $qu * $qu == $ct && $qu <= $qt;
            }
            my $pow4 = 0;
            my $non2 = $c;
            while (($non2 & 3) == 0) {
                ++$pow4;
                $non2 >>= 2;
            }
            if ($non2 & 1) {
                # worst case [ 2^pow4 (non2+1)/2 ]^2 - [2^pow4 (non2-1)/2 ]^2
                my $qmin = $q / (1 << $pow4);
                $qmin = ($qmin == int($qmin)) ? $qmin : (int($qmin) + 1);
                my $qmax = ($non2 + 1) >> 1;
                for my $qt ($qmin .. $qmax) {
                    my $ct = $qt * $qt - $non2;
                    next if $ct < 0;
                    my $qu = int(sqrt $ct);
                    # difference of two squares
                    do { ($f, $g) = (2, $qt); goto done } if $qu * $qu == $ct;
                }
            }
            # need three squares
            my $q3 = sqrt($c / 3);
            $q3 = ($q == int($q3)) ? $q3 : (int($q3) + 1);
            for my $qt ($q3 .. $q) {
                next unless defined nextf($c - $qt * $qt, $qt, 2);
                ($f, $g) = (3, $qt);
                goto done;
            }
            for (my $qt = $q + 1; 1; ++$qt) {
                next unless defined nextf($qt * $qt - $c, $qt, 2);
                ($f, $g) = (3, $qt);
                goto done;
            }
          done:
            $g[$c] = $g;
            $f;
        };
    }
    sub fck {
        my($c, $k) = @_;
        return +($c == 0) ? 0 : undef if $k == 0;
        $c = abs($c);
        return $f[$c][$k] // do {
            firstf($c) unless defined $g[$c];
            ($k >= $g[$c]) ? $f[$c][0] : nextf($c, $k);
        };
    }
}
