#!/opt/maths/bin/perl
use warnings;
use strict;
use Math::BigRat;

=head1 Colinear

For a polyomino S, let c(S) be the greatest number of points (at the centre
of the unit squares comprising the shape) that lie on any single line.
Find a(n, k), the number of k-ominoes S with c(S) <= n.

My initial estimate of max(a(5,k)) is in the range 10^9 to 10^11, so we
will write found k-ominoes to a file in a format that lets us use unix
utilities 'sort' and 'uniq' to find the duplicates.

A significant optimization is to associate a bitmap of disallowed points
with each shape, inherited by any child shapes generated from that parent.
We mark any point found to exceed our colinearity limit as disallowed, but
when we extend a shape by adding one of its neighbours we will also mark
the added point as disallowed in the parent, so that further child shapes
derived from it won't attempt to add that same neighbour. This ensures that
if from shape S we find two new shapes S+A and S+B, we will later attempt
to extend the first as S+A+B, but will not also attempt to extend the
second as S+B+A.

This approach is valid only if we handle parent shapes in the same order
they were generated; as such, we include an index in the entries we write,
and after sorting on the canonicalized shape for deduplication (using
a stable sort so that the earliest copy generated is the one retained),
we then sort the deduplicated results again on the index value.

We must also traverse the neighbours in a consistent order, so even
though we use the canonicalized orientation for deduplication we must
retain (or recover) the original orientation for further processing.

=cut

my $n = $ARGV[0] || 2;
for (my $k = 1; 1; ++$k) {
    my $fi = input_file($k);
    my $fo = output_file($k);
    my($ci, $co) = (0, 0);
    # For each unique shape of size one smaller ...
    while (my $src = fetch($fi)) {
        ++$ci;
        # Find neighbours of this shape that satisfy colinearity constraint;
        # mark each failing neighbour as always disallowed, for this shape
        # and any children.
        my @good = map {
            $src->colinear(@$_) <= $n
                ? ($_)
                : do { $src->disallow(@$_); () }
        } $src->neighbours;
        # For each of the good neighbours, create the new shape, and mark
        # the new point disallowed for future children of the source -
        # this avoids adding points (B, A) when we already add (A, B).
        for my $point (@good) {
            my $next = $src->add_new(@$point);
            $src->disallow(@$point);
            # We check duplicates on read, not on write.
            write_new($fo, $next, $point, $co);
            ++$co;
        }
    }
    close($fo);
    close($fi) unless ref($fi) eq 'ARRAY';
    # Number read of size k-1 is deduplicated count; number written of
    # size k is with duplicates.
    printf "a(%s, %s) = %s, wrote %s new (%.2f)\n",
            $n, $k - 1, $ci, $co, (times)[0];
    print("a($n, $k) = 0\n"), last if $co == 0;
}
exit 0;

sub input_file {
    my($k) = @_;
    # handle input of size 0 specially
    return [0] if $k == 1;
    my $f = sprintf 'log/r%d.%d', $n, $k - 1;
    my $fs = "${f}s";
    die "$f: no file found" unless -e $f;
    # The data has 3 fields: index, data, canonical.
    # We sort first on the canonical so that we can uniq on it, with
    # sort stability so that the occurrence with earliest index is kept;
    # then re-sort (numerically) by index.
    system(sprintf
        'sort --stable --key=3,3 <%s'
            . ' | uniq --skip-fields=2'
            . ' | sort --key=1n >%s',
        $f, $fs
    );
    open my $fh, '<', $fs or die "$fs: $!";
    return $fh;
}

sub output_file {
    my($k) = @_;
    my $f = sprintf 'log/r%d.%d', $n, $k;
    open my $fh, '>', $f or die "$f: $!";
    return $fh;
}

sub write_new {
    my($fh, $s, $point, $index) = @_;
    print $fh $s->writable($point, $index);
    return;
}

sub fetch {
    my($fh) = @_;
    if (ref($fh) eq 'ARRAY') {
        return undef if $fh->[0]++;
        return Shape->new_empty;
    }
    my $off = tell($fh);
    my $line = <$fh> // return undef;
    return Shape->parse($line, $off);
}

package Shape {
    sub new {
        my($class, $data) = @_;
        return bless $data, $class;
    }
    sub new_empty {
        my($class) = @_;
        my $self = $class->new({
            xmin => 0,
            xmax => -1,
            ymin => 0,
            ymax => -1,
            point => [],
            disallowed => [],
            neighbour => [('') x 2],
            count => 0,
            off => 0,
        });
        # set a seed neighbour
        $self->setv($self->neighbour, 1, 1);
        return $self;
    }
    sub parse {
        my($class, $line, $off) = @_;
        chomp $line;
        my($index, $other, $canonical) = split ' ', $line, 3;
        # source data used only on recovery for alignment
        my($orig, $disallowed, $src) = split ';', $other, 3;
        die "parse error" unless $orig =~ s{^(\d+):(\d+):}{};
        my($xspan, $yspan) = ($1, $2);
        my @pt_rows = split m{/}, $orig;
        my @dis_rows = split m{/}, $disallowed;
        # build pre-expanded
        my $self = $class->new({
            xmin => 2,
            xmax => $xspan + 1,
            ymin => 2,
            ymax => $yspan + 1,
            count => 0,
            point => [],
            disallowed => [],
            neighbour => [],
            off => $off,
        });
        my($pt, $dis, $nb) = @$self{qw{ point disallowed neighbour }};
        for my $i (0 .. $#pt_rows) {
            my $row = $pt_rows[$i];
            for my $j (0 .. length($row)) {
                next unless substr($row, $j, 1) eq '*';
                my($x, $y) = ($i + 2, $j + 2);
                $self->setv($pt, $x, $y);
                $self->unsetv($nb, $x, $y);
                for ([-1, 0], [1, 0], [0, -1], [0, 1]) {
                    my($xn, $yn) = ($x + $_->[0], $y + $_->[1]);
                    $self->setv($nb, $xn, $yn)
                            unless $self->hasv($pt, $xn, $yn);
                }
                ++$self->{count};
            }
        }
        for my $i (0 .. $#dis_rows) {
            my $row = $dis_rows[$i];
            for my $j (0 .. length($row)) {
                next unless substr($row, $j, 1) eq '*';
                my($x, $y) = ($i + 1, $j + 1);
                $self->setv($dis, $x, $y);
                $self->unsetv($nb, $x, $y);
            }
        }
        return $self;
    }
    sub count { shift->{count} }
    sub point { shift->{point} }
    sub neighbour { shift->{neighbour} }
    sub disallowed { shift->{disallowed} }
    sub clone {
        my($self) = @_;
        return ref($self)->new({
            %$self,
            point => [ @{ $self->point } ],
            disallowed => [ @{ $self->disallowed } ],
            neighbour => [ @{ $self->neighbour } ],
        });
    }
    sub neighbours {
        my($self) = @_;
        return $self->allv($self->neighbour);
    }
    sub disallow {
        my($self, $x, $y) = @_;
        $self->setv($self->disallowed, $x, $y);
        return;
    }
    sub writable {
        my($self, $point, $index) = @_;
        my $raw = $self->disp;
        my $dis = $self->rdd;
        my $canon = $self->canonical;
        return sprintf "%s %s %s\n",
                $index, join(';', $raw, $dis, $self->{off}, @$point), $canon;
    }
    sub canonical {
        my($self) = @_;
        return '' if $self->count == 0;
        my($xmin, $xmax, $ymin, $ymax) = @$self{qw{ xmin xmax ymin ymax }};
        my($xspan, $yspan) = ($xmax - $xmin, $ymax - $ymin);
        my($s, $t);
        my $pt = $self->point;
        if ($xspan <= $yspan) {
            $s = $self->disp($pt);
            my $tx = $self->invx($pt, $xmin, $xmax);

            $t = $self->disp($tx);
            $s = $t if $s gt $t;

            my $tr = $self->revx($pt, $ymin, $ymax);
            $t = $self->disp($tr);
            $s = $t if $s gt $t;

            my $trx = $self->invx($tr, $xmin, $xmax);
            $t = $self->disp($trx);
            $s = $t if $s gt $t;
        }

        if ($yspan <= $xspan) {
            local @$self{qw{ xmin xmax ymin ymax }} = ($ymin, $ymax, $xmin, $xmax);
            my $ty = $self->trans($pt, $xmin, $xmax, $ymin, $ymax);
            $t = $self->disp($ty);
            $s = $t if !defined($s) || $s gt $t;

            my $tyx = $self->invx($ty, $ymin, $ymax);
            $t = $self->disp($tyx);
            $s = $t if $s gt $t;

            my $tyr = $self->revx($ty, $xmin, $xmax);
            $t = $self->disp($tyr);
            $s = $t if $s gt $t;

            my $tyrx = $self->invx($tyr, $ymin, $ymax);
            $t = $self->disp($tyrx);
            $s = $t if $s gt $t;
        }
        return $s;
    }
    sub add_new {
        my($self, $x, $y) = @_;
        $self = $self->clone;
        if ($self->{count} == 0) {
            @$self{qw{ xmin xmax ymin ymax }} = ($x, $x, $y, $y);
        } else {
            $self->{xmin} = $x if $self->{xmin} > $x;
            $self->{xmax} = $x if $self->{xmax} < $x;
            $self->{ymin} = $y if $self->{ymin} > $y;
            $self->{ymax} = $y if $self->{ymax} < $y;
        }
        $self->setv($self->point, $x, $y);
        my $disallowed = $self->disallowed;
        $self->setv($disallowed, $x, $y);
        my $nb = $self->neighbour;
        $self->unsetv($nb, $x, $y);
        for ([-1, 0], [1, 0], [0, -1], [0, 1]) {
            my($xn, $yn) = ($x + $_->[0], $y + $_->[1]);
            $self->setv($nb, $xn, $yn)
                    unless $self->hasv($disallowed, $xn, $yn);
        }
        ++$self->{count};
        return $self;
    }
    sub expand {
        my($self) = @_;
        return if $self->count == 0;
        while ($self->{xmin} < 2) {
            unshift @{ $self->point }, '';
            unshift @{ $self->disallowed }, '';
            unshift @{ $self->neighbour }, '';
            ++$self->{xmin};
            ++$self->{xmax};
        }
        if ($self->{ymin} < 2) {
            for ($self->point, $self->disallowed, $self->neighbour) {
                @$_ = map "\x{0}" . $_, @$_;
            }
            $self->{ymin} += 8;
            $self->{ymax} += 8;
        }
        return;
    }
    sub colinear {
        my($self, $x, $y) = @_;
        my %seen;
        my $high = 0;
        for ($self->allv($self->point)) {
            my($x2, $y2) = @$_;
            my $v = ($y == $y2) ? "oo" : Math::BigRat->new($x - $x2, $y - $y2);
            ++$seen{$v};
            $high = $seen{$v} if $high < $seen{$v};
        }
# $x -= $self->{xmin}; $y -= $self->{ymin}; warn "col $high for [$x,$y] in @{[ $self->disp ]}\n";
        return $high + 1;
    }
    sub Dump {
        my($self) = @_;
        my @r = @$self{qw{ xmin xmax ymin ymax }};
        my @s = ($self->rdp, $self->rdd, $self->rdn);
        return sprintf <<EOS, $self->{count}, @r, @s;
count %s; xmin %s; xmax %s; ymin %s; ymax %s
pt: %s
ds: %s
nb: %s
EOS
    }
    sub rdisp {
        my($self, $data, $xmin, $xmax, $ymin, $ymax) = @_;
        return join '/', map {
            my $x = $_;
            join '', map {
                $self->hasv($data, $x, $_) ? '*' : '.'
            } $ymin .. $ymax;
        } $xmin .. $xmax;
    }
    sub rdp {
        my($self) = @_;
        return $self->rdisp($self->point, @$self{qw{ xmin xmax ymin ymax }});
    }
    sub rdd {
        my($self) = @_;
        return $self->rdisp($self->disallowed,
            $self->{xmin} - 1, $self->{xmax} + 1,
            $self->{ymin} - 1, $self->{ymax} + 1
        );
    }
    sub rdn {
        my($self) = @_;
        return $self->rdisp($self->neighbour,
            $self->{xmin} - 1, $self->{xmax} + 1,
            $self->{ymin} - 1, $self->{ymax} + 1
        );
    }
    sub disp {
        my($self, $data) = @_;
        $data //= $self->{point};
        my($xmin, $xmax, $ymin, $ymax) = @$self{qw{ xmin xmax ymin ymax }};
        my $xspan = $xmax - $xmin + 1;
        my $yspan = $ymax - $ymin + 1;
        return sprintf '%d:%d:%s',
                $xmax - $xmin + 1, $ymax - $ymin + 1,
                $self->rdisp($data, $xmin, $xmax, $ymin, $ymax);
    }
    sub hasv {
        my($self, $v, $x, $y) = @_;
        return 0 if $#$v < $x;
        return vec($v->[$x], $y, 1) ? 1 : 0;
    }
    sub setv {
        my($self, $v, $x, $y) = @_;
        push @$v, '' while @$v < $x;
        vec($v->[$x], $y, 1) = 1;
        return;
    }
    sub unsetv {
        my($self, $v, $x, $y) = @_;
        return if $#$v < $x;
        vec($v->[$x], $y, 1) = 0;
        if ($#$v == $x) {
            pop @$v while @$v && $v->[-1] !~ /[^\x{0}]/;
        }
        return;
    }
    sub allv {
        my($self, $v) = @_;
        return map {
            my $i = $_;
            my $vi = $v->[$i];
            my $len = 8 * length($vi);
            map [ $i, $_ ], grep vec($vi, $_, 1), 0 .. $len - 1;
        } 0 .. $#$v;
    }
    sub invx {
        my($self, $v, $xmin, $xmax) = @_;
        return [ ('') x $xmin, reverse @$v[ $xmin .. $xmax ] ];
    }
    sub revx {
        my($self, $v, $ymin, $ymax) = @_;
        my $w = [ ('') x @$v ];
        for my $i (0 .. $#$v) {
            my $src = $v->[$i];
            next if $src =~ /^\x{0}*\z/;
            my $dest = $w->[$i];
            for my $j (0 .. $ymax - $ymin) {
                vec($dest, $ymin + $j, 1) = vec($src, $ymax - $j, 1);
            }
            $w->[$i] = $dest;
        }
        return $w;
    }
    sub trans {
        my($self, $v, $xmin, $xmax, $ymin, $ymax) = @_;
        my $w = [ ('') x ($ymax + 1) ];
        for my $i ($xmin .. $xmax) {
            for my $j ($ymin .. $ymax) {
                vec($w->[$j], $i, 1) = vec($v->[$i] //= '', $j, 1);
            }
        }
        return $w;
    }
};

__END__

a(n) (A380991) = [1, 4, 15, 48, ...]
a(3, k) (A378169) = [
    1, 1, 2, 4, 9, 18, 37, 62,
    86, 78, 61, 34, 14, 4, 1, 0
]
a(4, k) (A380990) = [
    1, 1, 2, 5, 11, 31, 85, 262,
    764, 2255, 6341, 17221, 43994, 106205, 239367, 502611,
    977791, 1771624, 2989373, 4687803, 6819069, 9234529, 11622453, 13527854,
    14571011, 14643347, 13747913, 12041014, 9905945, 7763985, 5805906, 4139266,
    2858796, 1971455, 1368967, 942226, 618148, 368480, 186275, 73649,
    20236, 3476, 400, 96, 27, 12, 2, 1,
    0
]
a(5, k) = [
    1, 1, 2, 5, 12, 34, 104, 339,
    1133, 3845, 13080, 44374, 149495, 
    ...
]

number of polyominoes (A000105) = [
    1 1 2 5 12 35 108 369
    1285 4655 17073 63600 238591 901971 3426576 13079255
    50107909 192622052 742624232 2870671950 11123060678 43191857688 168047007728 654999700403
    2557227044764 9999088822075 39153010938487 153511100594603 602621953061978 2368347037571252 9317706529987950 36695016991712879
    144648268175306702 570694242129491412 2253491528465905342 8905339105809603405 35218318816847951974 139377733711832678648 551961891896743223274 2187263896664830239467
    8672737591212363420225 34408176607279501779592 136585913609703198598627 542473001706357882732070 2155600091107324229254415 8569720333296834568434605 34085105553123831158180217 135629410647775553284438364
    539916438668093786698843965 2150182610161041739167164220 8566301646855786503391647670 34140832502065121824070942627 136116710694919148806231527457 542874683702992552434145546370 2165873377717239478407665345440 8643839320316615721187562237534
    34507662858721137395351058631991 137801831798576866546096116428465 550453451340976338599795923539996
]

peak a(3,k) at k= 9 is A105(k)^0.6222
peak a(4,k) at k=26 is A105(k)^0.5512

% ./colinear 4
a(4, 1) = 1 (0.06)
a(4, 2) = 1 (0.06)
a(4, 3) = 2 (0.06)
a(4, 4) = 5 (0.07)
a(4, 5) = 11 (0.08)
a(4, 6) = 31 (0.12)
a(4, 7) = 85 (0.28)
a(4, 8) = 262 (0.86)
a(4, 9) = 764 (3.14)
a(4, 10) = 2255 (13.20)
a(4, 11) = 6341 (54.36)
a(4, 12) = 17221 (182.10)
a(4, 13) = 43994 (678.54)
a(4, 14) = 106205 (2172.64)
a(4, 15) = 239367 (6276.87)

